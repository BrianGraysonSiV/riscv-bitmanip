\chapter{XBitfield Extension}
\label{bfxp}

The most asked-for feature in XBitmanip is an instruction for bit field
extract. XBitmanip recommends the usage of {\tt slli} followed by {\tt slri}
for this operation and asks implementors to fuse this sequence into a single
macro-op. However, there are valid concerns regarding this approach:

\begin{itemize}
\item Not all processors that might want to implement a fast bitfield extract
can fuse macro-ops.
\item In some architectures it might be hard to fuse the two shift instructions
if one of them is using a 32-bit instruction encoding. Therefore the instruction
can not be fused if {\tt rd} $\ne$ {\tt rs1}.
\item {\tt bext} and {\tt bdep} can do a lot of the heavy lifting in applications that
would otherwise require many individual bitflied-extract operations. But smaller cores might not provide
a fast {\tt bext}/{\tt bdep} unit, or provide no hardware support for those instructions at all.
\end{itemize}

Therefore this chapter proposes the RISC-V XBitfield extension. Note that, unlike
XBitmanip, {\bf we do \underline{not} propose XBitfield for adoption as official RISC-V ISA extension}.

The encoding for a proper 32-bit bitfield extract instruction, if encoded
in a clean and future-safe way that scales all the way to RV128, would require
a 14 bit immediate (7 bits for start and 7 bits for length), or the equivalent
of 4 I-type instructions with full immediate length, or half of a major opcode,
way too wasteful for an official RISC-V ISA extension, especially for something
that can be encoded in the same space with two compressed instructions.

However, there is a tendency for implementors to fill the unused instruction
encoding space with a myriad of complex instructions with large immediates.~\cite{Ri5cy}

So might as well propose XBitfield, a custom, non-standard extension that uses
almost the entire major opcode 1111011 ({\it custom-3}) for a single bit-field
extract and place ({\tt bfxp}) instruction, effectively packing 3
shift-immediate operations and one OR in one single instruction.

The main goal here is that individual implementors can use the same patches for
compiler toolchains. By standardising one powerful but easy to implement
instruction instead of a whole range of simpler instructions we keep the
complexity of the extension low and ease adoption.

\section{Bit-field extract and place ({\tt bfxp}, {\tt bfxpc})}

The bit-field extract and place instruction extracts a bitfield of length
{\tt len} starting at bit position {\tt start}, creates a new value with
the extraced bitfield at offset {\tt dest}, and fills the other bits
in the output with {\tt rs2}.

The bit-field extract and place complement instruction does the same thing,
but first complements {\tt rs1}.

The immediate arguments {\tt start} and {\tt dest} are 5 bit unsigned
immediates on RV32 and a 6 bit unsigned immediates on RV64.

The immediate argument {\tt len} is an unsigned 5 bit immediates. On RV64 {\tt
len} $=$ 0 encodes for {\tt len} $=$ 32.  On RV32 {\tt len} $=$ 0 is reserved
for other instructions.

Instruction words with $\texttt{start}+\texttt{len}>\textrm{XLEN}$ or
$\texttt{dest}+\texttt{len}>\textrm{XLEN}$ are reserved for other instructions.

\input{bextcref-bfxp}

The assembler mnemonics for {\tt bfxp} and {\tt bfxpc} are as follows.

\begin{verbatim}
  bfxp  rd, rs1, rs2, start, len, dest
  bfxpc rd, rs1, rs2, start, len, dest
\end{verbatim}

{\tt bfxp}/{\tt bfxpc} occupies the {\it custom-3} major opcode:

\begin{center}
\begin{tabular}{M@{}F@{}R@{}W@{}F@{}O}
\instbitrange{31}{18} &
\instbitrange{17}{15} &
\instbitrange{14}{11} &
\multicolumn{1}{c}{\scriptsize 10} &
\instbitrange{9}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm} &
\multicolumn{1}{c|}{rs1$'$} &
\multicolumn{1}{c|}{imm} &
\multicolumn{1}{c|}{rs2$^*$} &
\multicolumn{1}{c|}{rd$'$} &
\multicolumn{1}{c|}{1111011} \\
\hline
14 & 3 & 4 & 1 & 3 & 7 \\
\cline{1-1}
\cline{3-3}
\multicolumn{1}{c}{
	\rotatebox{90}{\tt start[3]}    % 31
	\rotatebox{90}{\tt start[2]}    % 30
	\rotatebox{90}{\tt start[1]}    % 29
	\rotatebox{90}{\tt start[0]}    % 28
	\rotatebox{90}{\tt \ \ len[3]}  % 27
	\rotatebox{90}{\tt \ \ len[2]}  % 26
	\rotatebox{90}{\tt \ \ len[1]}  % 25
	\rotatebox{90}{\tt \ \ len[0]}  % 24
	\rotatebox{90}{\tt \ dest[5]}   % 23
	\rotatebox{90}{\tt \ dest[4]}   % 22
	\rotatebox{90}{\tt \ dest[3]}   % 21
	\rotatebox{90}{\tt \ dest[2]}   % 20
	\rotatebox{90}{\tt \ dest[1]}   % 19
	\rotatebox{90}{\tt \ dest[0]}   % 18
} & &
\multicolumn{1}{c}{
	\rotatebox{90}{\tt start[5]}    % 14
	\rotatebox{90}{\tt start[4]}    % 13
	\rotatebox{90}{\tt \ \ len[4]}  % 12
	\rotatebox{90}{\tt \ \ bfxpc}   % 11
} & & &
\end{tabular}
\end{center}

With rs1$'$ and rd$'$ interpreted as in ``C'' opcodes
($\textrm{rs1} = \textrm{rs1$'$}+8$, $\textrm{rd} = \textrm{rd$'$}+8$),
and rs2$^* = 0$ encoding for $\textrm{rs2} = \textrm{x0 (zero)}$ and
rs2$^* = 1$ encoding for $\textrm{rs2} = \textrm{rd}$.

The bits from {\tt start}, {\tt len}, and {\tt dest} are placed in the
immediate fields in a manner that aims at maximizing the usefulness of the
remaining brownfield in the {\it custom-3} opcode: On RV64, if instruction bits
14:12 are all set (funct3 = 111), then the instruction is reserved if any of
the bits 31:24 are set.

\section{ZBitfield extension using 48-bit encoding}

The {\tt bfxp}/{\tt bfxpc} instructions can be cleanly encoded using a 48-bit
instruction format. For example:

\begin{center}
\begin{tabular}{R@{}R@{}R@{}Y@{}Y@{}Y@{}S@{}F@{}}
\instbitrange{47}{41} &
\instbitrange{40}{34} &
\instbitrange{33}{27} &
\instbitrange{26}{22} &
\instbitrange{21}{17} &
\instbitrange{16}{12} &
\instbitrange{11}{4} &
\instbitrange{3}{0} \\
\hline
\multicolumn{1}{|c|}{start} &
\multicolumn{1}{c|}{len} &
\multicolumn{1}{c|}{dest} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{OP-BFXP} &
\multicolumn{1}{c|}{0111} \\
\hline
\multicolumn{1}{|c|}{start} &
\multicolumn{1}{c|}{len} &
\multicolumn{1}{c|}{dest} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{OP-BFXPC} &
\multicolumn{1}{c|}{0111} \\
\hline
7 & 7 & 7 & 5 & 5 & 5 & 8 & 4 \\
\end{tabular}
\end{center}

There are no standard instruction formats for 48-bit instructions yet, and no
RISC-V processors that support instructions $>32$ bits. But when they become a
thing, a ZBitfield extension using a 48-bit encoding should be considered.

\section{Evaluation: Decoding RISC-V Immediates}

The following code snippets decode and sign-extend the immedate from RISC-V
S-type, B-type, J-type, and CJ-type instructions. They are nice ``nothing up my
sleeve''-examples for real-world bit permutations.

\begin{small}
\begin{center}
\begin{tabular}{p{0in}p{0.4in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.4in}p{0.6in}p{0.4in}p{0.6in}p{0.7in}l}
& & & & & & & & & & \\
                      &
\multicolumn{1}{l}{\instbit{31}} &
\multicolumn{1}{r}{\instbit{27}} &
\instbit{26} &
\instbit{25} &
\multicolumn{1}{l}{\instbit{24}} &
\multicolumn{1}{r}{\instbit{20}} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\cline{2-11}

&
\multicolumn{4}{|c|}{imm[11:5]} &
\multicolumn{2}{c|}{} &
\multicolumn{1}{c|}{} &
\multicolumn{1}{c|}{} &
\multicolumn{1}{c|}{imm[4:0]} &
\multicolumn{1}{c|}{} & S-type \\
\cline{2-11}

&
\multicolumn{4}{|c|}{imm[12$\vert$10:5]} &
\multicolumn{2}{c|}{} &
\multicolumn{1}{c|}{} &
\multicolumn{1}{c|}{} &
\multicolumn{1}{c|}{imm[4:1$\vert$11]} &
\multicolumn{1}{c|}{} & B-type \\
\cline{2-11}

&
\multicolumn{8}{|c|}{imm[20$\vert$10:1$\vert$11$\vert$19:12]} &
\multicolumn{1}{c|}{} &
\multicolumn{1}{c|}{} & J-type \\
\cline{2-11}

\end{tabular}

\begin{tabular}{p{0in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}l}
& & & & & & & & & & \\
                      &
\instbit{15} &
\instbit{14} &
\instbit{13} &
\multicolumn{1}{c}{\instbit{12}} &
\instbit{11} &
\instbit{10} &
\instbit{9} &
\instbit{8} &
\instbit{7} &
\instbit{6} &
\multicolumn{1}{c}{\instbit{5}} &
\instbit{4} &
\instbit{3} &
\instbit{2} &
\instbit{1} &
\instbit{0} \\
\cline{2-17}

&
\multicolumn{3}{|c|}{} &
\multicolumn{11}{c|}{imm[11$\vert$4$\vert$9:8$\vert$10$\vert$6$\vert$7$\vert$3:1$\vert$5]} &
\multicolumn{2}{c|}{} & CJ-type \\
\cline{2-17}

\end{tabular}
\end{center}
\end{small}

\begin{multicols}{2}
\begin{verbatim}
  decode_s:
    bfxp a1, a0, zero, 7, 5, 20
    bfxp a0, a0, a1, 25, 7, 25
    c.srai a0, 20
    ret

  decode_b:
    bfxp a1, a0, zero, 7, 1, 30
    bfxp a1, a0, a1, 25, 6, 24
    bfxp a1, a0, a1, 8, 4, 20
    bfxp a0, a0, a1, 31, 1, 31
    c.srai a0, 19
    ret

  decode_j:
    bfxp a1, a0, zero, 21, 10, 12
    bfxp a1, a0, a1, 20, 1, 22
    bfxp a1, a0, a1, 12, 8, 23
    bfxp a0, a0, a1, 31, 1, 31
    c.srai a0, 11
    ret

  decode_cj:
    bfxp a1, a0, zero, 11, 1, 24
    bfxp a1, a0, a1, 9, 2, 28
    bfxp a1, a0, a1, 8, 1, 30
    bfxp a1, a0, a1, 7, 1, 26
    bfxp a1, a0, a1, 6, 1, 27
    bfxp a1, a0, a1, 3, 3, 21
    bfxp a1, a0, a1, 2, 1, 25
    bfxp a0, a0, a1, 12, 1, 31
    c.srai a0, 20
    ret
\end{verbatim}
\end{multicols}
