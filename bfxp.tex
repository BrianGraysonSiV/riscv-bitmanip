\chapter{XBitfield Extension}
\label{bfxp}

The most asked-for feature in XBitmanip is an instruction for bit field
extract. XBitmanip recommends the usage of {\tt slli} followed by {\tt slri}
for this operation and asks implementors to fuse this sequence into a single
macro-op. However, there are valid concerns regarding this approach:

\begin{itemize}
\item Not all processors that might want to implement a fast bitfield extract
can fuse macro-ops.
\item In some architectures it might be hard to fuse the two shift instructions
if one of them is using a 32-bit instruction encoding. Therefore the instruction
can not be fused if {\tt rd} $\ne$ {\tt rs1}.
\end{itemize}

Therefore this chapter proposes the RISC-V XBitfield extension. Note that, unlike
XBitmanip, {\bf we do \underline{not} propose XBitfield for adoption as official RISC-V ISA extension}.

The encoding for a proper 32-bit bitfield extract instruction, if encoded
in a clean and future-safe way that scales all the way to RV128, would require
a 14 bit immediate (7 bits for start and 7 bits for length), or the equivalent
of 4 I-type instruction with full immediate length, or half of a major opcode,
way too wasteful for an official RISC-V ISA extension, especially for something
that can be encoded in the same space with two compressed instructions.

However, there is a tendency for implementors to fill the unused instruction
encoding space with a myriad of complex instructions with large immediates.~\cite{Ri5cy}

So we propose XBitfield, a custom, non-standard extension that uses the entire
major opcode 1111011 ({\it custom-3}) for a single bit-field extract and place
({\tt bfxp}) instruction, effectively packing 3 shift-immediate operations and
one OR in one single instruction.

The goal here is that individual implementors can easily share patches for
compiler toolchains. By standardising one powerful but easy to implement
instruction instead of a whole range of simpler instructions we keep the
complexity of the extension low.

\section{Bit-field extract and place ({\tt bfxp})}

The bit-field extract and place instruction extracts a bitfield of length
{\tt len} starting at bit position {\tt start}, creates a new value with
the extraced bitfield at offset {\tt dest}, and OR's that with {\tt rs2}.

The immediate argument {\tt start} is a 5 bit immediate on RV32 and a 6 bit
immediate on RV64.

The immediate arguments {\tt len} and {\tt dest} are unsigned
5 bit immediates. On RV64 {\tt len} $=$ 0 encodes for {\tt len} $=$ 32.

Instruction words with $\texttt{start}+\texttt{len}>\textrm{XLEN}$ or
$\texttt{dest}+\texttt{len}>\textrm{XLEN}$ are reserved for other instructions.

\input{bextcref-bfxp}

The assembler mnemonic for {\tt bfxp} is as follows.

\begin{verbatim}
  bfxp rd, rs1, rs2, start, len, dest
\end{verbatim}

{\tt bfxp} occupies the {\it custom-3} major opcode:

\begin{center}
\begin{tabular}{T@{}F@{}W@{}F@{}R@{}F@{}O}
\instbitrange{31}{23} &
\instbitrange{22}{20} &
\instbitrange{19}{18} &
\instbitrange{17}{15} &
\instbitrange{14}{10} &
\instbitrange{9}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{F9} &
\multicolumn{1}{c|}{rs2$^*$} &
\multicolumn{1}{c|}{F2} &
\multicolumn{1}{c|}{rs1$'$} &
\multicolumn{1}{c|}{F5} &
\multicolumn{1}{c|}{rd$'$} &
\multicolumn{1}{c|}{1111011} \\
\hline
9 & 3 & 2 & 3 & 5 & 3 & 7 \\
\end{tabular}
\end{center}

With rs1$'$ and rd$'$ interpreted as in ``C'' opcodes
($\textrm{rs1} = \textrm{rs1$'$}+8$, $\textrm{rd} = \textrm{rd$'$}+8$),
and rs2$^*$ being interpreted the same way, except that $\textrm{rs2} = 0$
when $\textrm{rs2$^*$} = 0$.

The bits from {\tt start}, {\tt len}, and {\tt dest} are placed in
F9, F5, and F7 in an order that tries the maximize the usefulness of the
remaining brownfield in the {\it custom-3} opcode:

\begin{center}
\begin{tabular}{c|c|c|c|c|c|l}
\cline{1-6}
\multicolumn{1}{|c|}{F5[4]} & F5[3] & F9[8] & F9[6] & F5[1] & F5[0] & {\tt start} \\
\cline{1-6}
                            & F5[2] & F9[7] & F9[5] & F2[1] & F2[0] & {\tt len} \\
\cline{2-6}
                            & F9[4] & F9[3] & F9[2] & F9[1] & F9[0] & {\tt dest} \\
\cline{2-6}
\end{tabular}
\end{center}

Or the inverse mapping:

\begin{verbatim}
  F9 := {start[3], len[3], start[2], len[2], dest[4:0]}
  F5 := {start[5:4], len[4], start[1:0]}
  F2 := len[1:0]
\end{verbatim}

\section{Evaluation: Decoding RISC-V Immediates}

The following code snippets decode and sign-extend the immedate from RISC-V
S-type, B-type, J-type, and CJ-type instructions. They are nice ``nothing up my
sleeve''-examples for real-world bit permutations.

\begin{small}
\begin{center}
\begin{tabular}{p{0in}p{0.4in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.4in}p{0.6in}p{0.4in}p{0.6in}p{0.7in}l}
& & & & & & & & & & \\
                      &
\multicolumn{1}{l}{\instbit{31}} &
\multicolumn{1}{r}{\instbit{27}} &
\instbit{26} &
\instbit{25} &
\multicolumn{1}{l}{\instbit{24}} &
\multicolumn{1}{r}{\instbit{20}} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\cline{2-11}

&
\multicolumn{4}{|c|}{imm[11:5]} &
\multicolumn{2}{c|}{} &
\multicolumn{1}{c|}{} &
\multicolumn{1}{c|}{} &
\multicolumn{1}{c|}{imm[4:0]} &
\multicolumn{1}{c|}{} & S-type \\
\cline{2-11}

&
\multicolumn{4}{|c|}{imm[12$\vert$10:5]} &
\multicolumn{2}{c|}{} &
\multicolumn{1}{c|}{} &
\multicolumn{1}{c|}{} &
\multicolumn{1}{c|}{imm[4:1$\vert$11]} &
\multicolumn{1}{c|}{} & B-type \\
\cline{2-11}

&
\multicolumn{8}{|c|}{imm[20$\vert$10:1$\vert$11$\vert$19:12]} &
\multicolumn{1}{c|}{} &
\multicolumn{1}{c|}{} & J-type \\
\cline{2-11}

\end{tabular}

\begin{tabular}{p{0in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}l}
& & & & & & & & & & \\
                      &
\instbit{15} &
\instbit{14} &
\instbit{13} &
\multicolumn{1}{c}{\instbit{12}} &
\instbit{11} &
\instbit{10} &
\instbit{9} &
\instbit{8} &
\instbit{7} &
\instbit{6} &
\multicolumn{1}{c}{\instbit{5}} &
\instbit{4} &
\instbit{3} &
\instbit{2} &
\instbit{1} &
\instbit{0} \\
\cline{2-17}

&
\multicolumn{3}{|c|}{} &
\multicolumn{11}{c|}{imm[11$\vert$4$\vert$9:8$\vert$10$\vert$6$\vert$7$\vert$3:1$\vert$5]} &
\multicolumn{2}{c|}{} & CJ-type \\
\cline{2-17}

\end{tabular}
\end{center}
\end{small}

\begin{multicols}{2}
\begin{verbatim}
  decode_s:
    bfxp a1, a0, zero, 7, 5, 20
    bfxp a0, a0, a1, 25, 5, 25
    c.srai a0, 20
    ret

  decode_b:
    bfxp a1, a0, zero, 7, 1, 30
    bfxp a1, a0, a1, 25, 4, 24
    bfxp a1, a0, a1, 8, 4, 20
    bfxp a0, a0, a1, 31, 1, 31
    c.srai a0, 19
    ret

  decode_j:
    bfxp a1, a0, zero, 21, 12, 11
    bfxp a1, a0, a1, 20, 1, 22
    bfxp a1, a0, a1, 12, 8, 23
    bfxp a0, a0, a1, 31, 1, 31
    c.srai a0, 11
    ret

  decode_cj:
    bfxp a1, a0, zero, 11, 1, 24
    bfxp a1, a0, a1, 9, 2, 28
    bfxp a1, a0, a1, 8, 1, 30
    bfxp a1, a0, a1, 7, 1, 26
    bfxp a1, a0, a1, 6, 1, 27
    bfxp a1, a0, a1, 3, 3, 21
    bfxp a1, a0, a1, 2, 1, 25
    bfxp a0, a0, a1, 12, 1, 31
    c.srai a0, 20
    ret
\end{verbatim}
\end{multicols}
