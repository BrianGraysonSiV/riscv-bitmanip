\chapter{Discussion}

\section{Frequently Asked Questions}

\subsubsection{\texttt{grev} seems to be overly complicated? Do we really need it?}

The \texttt{grev} instruction can be used to build a wide range of common
bit permutation instructions, such as endianess conversion or bit reversal.

If \texttt{grev} were removed from this spec we would need to add a few
new instructions in its place for those operations.

\subsubsection{Do we really need all the \texttt{*W} opcodes for 32 bit ops on RV64?}

I don't know. I think nobody does know at the moment. But they add very little
complexity to the core. So the only question is if it is worth the encoding
space. We need to run proper experiments with compilers that support those
instructions. So they are in for now and if future evaluations show that they
are not worth the encoding space then we can still throw them out.

\subsubsection{Why only \texttt{andc} and not any other complement operators?}

Early versions of this spec also included other \texttt{*c} operators. But
experiments\footnote{http://svn.clifford.at/handicraft/2017/bitcode/} have show that
\texttt{andc} is much more common in bit manipulation code than any other operators.
Especially because it is commonly used in \texttt{mix} and \texttt{mux} operations.

\subsubsection{Why \texttt{andc}? It can easily be emulated using \texttt{and} and \texttt{not}.}

Yes, and we did not include any other ALU+complement operators. But \texttt{andc}
is so common (mostly because of the \texttt{mix} and \texttt{mux} patterns), and
its implementation is so cheap, that we decided to dedicate an R-type instruction
to the operation.

\subsubsection{The shift-ones instructions can be emulated using {\tt not} and logical shift? Do we really need it?}

Yes, a shift-ones instruction can easily be implemented using the logical shift
instructions, with a bitwise invert before and after it. (This is literally the
code we are using in the reference C implementation of shift-ones.)

We have decided to include it for now so that we can collect benchmark data
before making a final decision on the inclusion or exclusion of those
instructions. The main objection here is instruction encoding space. The
hardware overhead of adding this functionality to a shifter is relatively low.

\subsubsection{BEXT/BDEP look like really expensive operations. Do we really need them?}

Yes, they are expensive, but not as expensive as one might expect. A
single-cycle 32 bit BEXT+BDEP+GREV core can be implemented in less space than a
single-cycle 16x16 bit multiplier with 32 bit output.\footnote{https://github.com/cliffordwolf/bextdep}

It is also important to keep in mind that implementing those operations in
software is very expensive. Hacker's Delight contains a highly optimized
software implementation of 32-bit BEXT that requires $>120$ instructions. Their
BDEP software implementation requires $>160$ instructions. (Please disregard the
``hardware-oriented algorithm'' described in Hacker's Delight. It is
extremely expensive compared to other implementations.\footnote{https://github.com/cliffordwolf/bextdep})

\subsubsection{But do we really need 64-bit BEXT/BDEP?}

Good question. A 64-bit BEXT/BDEP unit certainly is more than 2x the size of a
32-bit unit and in most cases 32-bit would be sufficient. It is also not very difficult
to emulate 64-bit BEXT/BDEP using 32-bit BEXT/BDEP. On RV64 (with data in {\tt a0} and
mask in {\tt a1}):

\begin{multicols}{2}
\begin{minipage}{\linewidth}
\begin{verbatim}
  bext64:
    pcntw a2, a1
    bextw a3, a0, a1
    c.srli a0, 32
    c.srli a1, 32
    bextw a0, a0, a1
    sloi a1, zero, 32
    c.and a3, a1
    c.and a0, a1
    sll a0, a2
    c.or a0, a3
    ret
\end{verbatim}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{verbatim}
  bdep64:
    pcntw a2, a1
    bdepw a3, a0, a1
    srl a0, a0, a2
    c.srli a1, 32
    bdepw a0, a0, a1
    c.slli a0, 32
    c.slli a3, 32
    c.srli a3, 32
    c.or a0, a3
    ret
\end{verbatim}
\end{minipage}
\end{multicols}

However, one solution here would be to still reserve the opcode for 64-bit
BEXT/BDEP and leave it to the implementation to decide whether to implement the
function in hardware or emulating it using a software trap.

\section{Analysis of used encoding space}

So how much encoding space is used by the XBitmanip extension?

\begin{longtable}[c]{@{}rr|rr|l@{}}
\caption{XBitmanip encoding space ($log2$, i.e. in equivalent number of bits)}\tabularnewline
\toprule
\multicolumn{2}{c}{RV32} & \multicolumn{2}{c}{RV64} & Instruction\tabularnewline
\midrule
\endfirsthead
\toprule
\multicolumn{2}{c}{RV32} & \multicolumn{2}{c}{RV64} & Instruction\tabularnewline
\midrule
\endhead
3x &  0 & 6x &  0 & CLZ, CLZW, CTZ, CTZW, PCNT, PCNTW\tabularnewline
\midrule
2x & 15 & 4x & 15 & GREV, GREVW, GREVIW, ZIPW\tabularnewline
2x & 15 & 2x & 16 & GREVI, ZIP\tabularnewline
\midrule
2x & 15 & 6x & 15 & SLO, SRO, SLOW, SROW, SLOIW, SROIW\tabularnewline
2x & 15 & 2x & 16 & SLOI, SROI\tabularnewline
\midrule
2x & 15 & 5x & 15 & ROR, ROL, RORW, ROLW, RORIW\tabularnewline
1x & 15 & 1x & 16 & RORI\tabularnewline
\midrule
3x & 15 & 3x & 15 & ANDC, BEXT, BDEP\tabularnewline
   &    & 3x & 15 & ANDCW, BEXTW, BDEPW\tabularnewline
\midrule
3x &  4 & 3x &  4 & C.NEG, C.NOT, C.BREV\tabularnewline
\bottomrule
\end{longtable}

We do not count any encoding space for the unary instructions {\tt clz}, {\tt
clzw}, {\tt ctz}, {\tt ctzw}, {\tt pcnt}, and {\tt pcntw} because they can
be implemented in the reserved modes in {\tt zip}.

The compressed encoding space is $\approx 15.6$ bits wide.

$$ log_2(3 \cdot 2^{14}) \approx 15.585 $$

The compressed XBitmanip instructions need the equivalent of a 5.6 bit
encoding space, or $\approx 0.1\%$ of the total $\approx 15.6$ bits available.

$$ log_2(3 \cdot 2^4) \approx 5.585 $$
$$ 100 / (2^{15.585-5.585}) \approx 0.098 $$

On RV32, XBitmanip requires the equivalent of a $\approx 18.8$ bit encoding space in
the uncompressed encoding space. For comparison: A single standard I-type
instruction (such as \texttt{ADDI} or \texttt{SLTIU}) requires a $22$ bit
encoding space. I.e. the entire RV32 XBitmanip extension needs less than
one-eighth of the encoding space of the \texttt{SLTIU} instruction.

$$ log_2(14\cdot2^{15}) \approx 18.807 $$

On RV64, XBitmanip requires the equivalent of a $\approx 20.0$ bit encoding
space in the uncompressed encoding space. I.e. the entire RV64 XBitmanip
extension needs about one-quarter of the encoding space of the \texttt{SLTIU}
instruction.

$$ log_2(21\cdot2^{15} + 5\cdot2^{16}) \approx 19.954 $$
