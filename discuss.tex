\chapter{Discussion}

\section{Frequently Asked Questions}

\subsubsection{\texttt{grev} seems to be overly complicated? Do we really need it?}

The \texttt{grev} instruction can be used to build a wide range of common
bit permutation instructions, such as endianess conversion or bit reversal.

If \texttt{grev} were removed from this spec we would need to add a few
new instructions in its place for those operations.

\subsubsection{Do we really need all the \texttt{*W} opcodes for 32 bit ops on RV64?}

I don't know. I think nobody does know at the moment. But they add very little
complexity to the core. So the only question is if it is worth the encoding
space. We need to run proper experiments with compilers that support those
instructions. So they are in for now and if future evaluations show that they
are not worth the encoding space then we can still throw them out.

\subsubsection{Why only \texttt{andc} and not any other complement operators?}

Early versions of this spec also included other \texttt{*c} operators. But
experiments\footnote{http://svn.clifford.at/handicraft/2017/bitcode/} have show that
\texttt{andc} is much more common in bit manipulation code than any other operators.
Especially because it is commonly used in \texttt{mix} and \texttt{mux} operations.

\subsubsection{Why \texttt{andc}? It can easily be emulated using \texttt{and} and \texttt{not}.}

Yes, and we did not include any other ALU+complement operators. But \texttt{andc}
is so common (mostly because of the \texttt{mix} and \texttt{mux} patterns), and
its implementation is so cheap, that we decided to dedicate an R-type instruction
to the operation.

\subsubsection{The shift-ones instructions can be emulated using {\tt not} and logical shift? Do we really need it?}

Yes, a shift-ones instruction can easily be implemented using the logical shift
instructions, with a bitwise invert before and after it. (This is literally the
code we are using in the reference C implementation of rotate shift.)

We have decided to include it for now so that we can collect benchmark data before
making a final decision on the inclusion or exclusion of those instructions.

\subsubsection{BEXT/BDEP look like really expensive operations. Do we really need them?}

Yes, they are expensive, but not as expensive as one might expect. A
single-cycle 32 bit BEXT+BDEP+GREV core can be implemented in less space than a
single-cycle 16x16 bit multiplier with 32 bit output.\footnote{https://github.com/cliffordwolf/bextdep}

It is also important to keep in mind that implementing those operations in
software is very expensive. Hacker's Delight contains a highly optimized
software implementation of 32-bit BEXT that requires $>120$ instructions. Their
BDEP software implementation requires $>160$ instructions. (Please disregard the
``hardware-oriented algorithm'' described in Hacker's Delight. It is
extremely expensive compared to other implementations.\footnote{https://github.com/cliffordwolf/bextdep})

\subsubsection{But do we really need 64-bit BEXT/BDEP?}

Good question. A 64-bit BEXT/BDEP unit certainly is more than 2x the size of a
32-bit unit and in most cases 32-bit would be sufficient.

However, one solution here would be to still reserve the opcode for 64-bit
BEXT/BDEP and leave it to the implementation to decide whether to implement the
function in hardware or emulating it using a software trap.

\subsubsection{SHUFFLE looks like a really expensive operation. Do we really need it?}

Even though this instruction looks expensive, it is actually quite simple to
implement.  The butterfly operation can just reuse the butterfly circuit that
is already present to support the {\tt grev} instruction, and zip and unzip are
very cheap to implement (just one additional word-wide mux each). The ``return
0'' part for nonzero commands and reserved modes is also very cheap.

Considering that SHUFFLE is very cheap to implement on top an existing GREV
implementation, and considering that it only requires a single R-type
instruction, and that software emulation of similar functionality requires tens
of instructions (and/or multiplications with large ``magic constants''), it is a
relatively good option.

With dedicated unary ZIP/UNZIP instructions it would be possible to emulate
a single SHUFFLE instruction in under 10 instructions. For example,
emulating a single OMEGA instruction (input in a0 and mask in a1):

\begin{verbatim}
  grevi t0, a0, 0
  zip a1, a1
  and t0, t0, a1
  andc a0, a0, a1
  or a0, a0, t0
  unzip a0, a0
\end{verbatim}

Or emulating a single BFLY(2) instruction:

\begin{verbatim}
  grevi t0, a0, 0
  zip a1, a1
  zip a1, a1
  zip a1, a1
  and t0, t0, a1
  andc a0, a0, a1
  or a0, a0, t0
\end{verbatim}

This is not too bad, but considering that a single 32-bit permutation takes up to
9 of those, it is probably not a viable option for many bit permutations found
in real-world applications.

\section{Analysis of used encoding space}

So how much encoding space is used by the XBitmanip extension?

\begin{longtable}[c]{@{}rr|rr|l@{}}
\caption{XBitmanip encoding space ($log2$, i.e. in equivalent number of bits)}\tabularnewline
\toprule
\multicolumn{2}{c}{RV32} & \multicolumn{2}{c}{RV64} & Instruction\tabularnewline
\midrule
\endfirsthead
\toprule
\multicolumn{2}{c}{RV32} & \multicolumn{2}{c}{RV64} & Instruction\tabularnewline
\midrule
\endhead
3x & 10 & 6x & 10 & CLZ, CLZW, CTZ, CTZW, PCNT, PCNTW\tabularnewline
\midrule
1x & 15 & 3x & 15 & GREV, GREVW, GREVIW\tabularnewline
1x & 15 & 1x & 16 & GREVI\tabularnewline
\midrule
2x & 15 & 6x & 15 & SLO, SRO, SLOW, SROW, SLOIW, SROIW\tabularnewline
2x & 15 & 2x & 16 & SLOI, SROI\tabularnewline
\midrule
2x & 15 & 5x & 15 & ROR, ROL, RORW, ROLW, RORIW\tabularnewline
1x & 15 & 1x & 16 & RORI\tabularnewline
\midrule
4x & 15 & 4x & 15 & ANDC, BEXT, BDEP, SHUFFLE\tabularnewline
   &    & 4x & 15 & ANDCW, BEXTW, BDEPW, SHUFFLEW\tabularnewline
\midrule
3x &  4 & 3x &  4 & C.NEG, C.NOT, C.BREV\tabularnewline
\bottomrule
\end{longtable}

The compressed encoding space is $\approx 15.6$ bits wide.

$$ log_2(3 \cdot 2^{14}) \approx 15.585 $$

The compressed XBitmanip instructions need the equivalent of a 5.6 bit
encoding space, or $\approx 0.1\%$ of the total $\approx 15.6$ bits available.

$$ log_2(3 \cdot 2^4) \approx 5.585 $$
$$ 100 / (2^{15.585-5.585}) \approx 0.098 $$

On RV32, XBitmanip requires the equivalent of a $\approx 18.7$ bit encoding space in
the uncompressed encoding space. For comparison: A single standard I-type
instruction (such as \texttt{ADDI} or \texttt{SLTIU}) requires a $22$ bit
encoding space. I.e. the entire RV32 XBitmanip extension needs less than
one-eighth of the encoding space of the \texttt{SLTIU} instruction.

$$ log_2(3\cdot2^{10} + 13\cdot2^{15}) \approx 18.711 $$

On RV64, XBitmanip requires the equivalent of a $\approx 19.9$ bit encoding
space in the uncompressed encoding space. I.e. the entire RV64 XBitmanip
extension needs less than one-quarter of the encoding space of the
\texttt{SLTIU} instruction.

$$ log_2(6\cdot2^{10} + 22\cdot2^{15} + 4\cdot2^{16}) \approx 19.911 $$

