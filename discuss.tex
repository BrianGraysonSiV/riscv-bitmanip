\chapter{Discussion}

\section{Frequently Asked Questions}

\subsubsection{\texttt{grev} seems to be overly complicated? Do we really need it?}

The \texttt{grev} instruction can be used to build a wide range of common
bit permutation instructions, such as endianess conversion or bit reversal.

If \texttt{grev} were removed from this spec we would need to add a few
new instructions in its place for those operations.

\subsubsection{Do we really need all the \texttt{*W} opcodes for 32 bit ops on RV64?}

I don't know. I think nobody does know at the moment. But they add very little
complexity to the core. So the only question is if it is worth the encoding
space. We need to run proper experiments with compilers that support those
instructions. So they are in for now and if future evaluations show that they
are not worth the encoding space then we can still throw them out.

\subsubsection{Why only \texttt{andc} and not any other complement operators?}

Early versions of this spec also included other \texttt{*c} operators. But
experiments have shown that \texttt{andc} is much more common in bit
manipulation code than any other operators.~\cite{Wolf17A}
Especially because it is commonly used in \texttt{mix} and \texttt{mux} operations.

\subsubsection{Why \texttt{andc}? It can easily be emulated using \texttt{and} and \texttt{not}.}

Yes, and we did not include any other ALU+complement operators. But \texttt{andc}
is so common (mostly because of the \texttt{mix} and \texttt{mux} patterns), and
its implementation is so cheap, that we decided to dedicate an R-type instruction
to the operation.

\subsubsection{The shift-ones instructions can be emulated using {\tt not} and logical shift? Do we really need it?}

Yes, a shift-ones instruction can easily be implemented using the logical shift
instructions, with a bitwise invert before and after it. (This is literally the
code we are using in the reference C implementation of shift-ones.)

We have decided to include it for now so that we can collect benchmark data
before making a final decision on the inclusion or exclusion of those
instructions. The main objection here is instruction encoding space. The
hardware overhead of adding this functionality to a shifter is relatively low.

\subsubsection{BEXT/BDEP look like really expensive operations. Do we really need them?}

Yes, they are expensive, but not as expensive as one might expect. A
single-cycle 32 bit BEXT+BDEP+GREV core can be implemented in less space than a
single-cycle 16x16 bit multiplier with 32 bit output.~\cite{Wolf17B}

It is also important to keep in mind that implementing those operations in
software is very expensive. Hacker's Delight contains a highly optimized
software implementation of 32-bit BEXT that requires $>120$ instructions. Their
BDEP software implementation requires $>160$ instructions. (Please disregard the
``hardware-oriented algorithm'' described in Hacker's Delight. It is
extremely expensive compared to other implementations.~\cite{Wolf17B})

\subsubsection{But do we really need 64-bit BEXT/BDEP?}

Good question. A 64-bit BEXT/BDEP unit certainly is more than 2x the size of a
32-bit unit and in most cases 32-bit would be sufficient. It is also not very difficult
to emulate 64-bit BEXT/BDEP using 32-bit BEXT/BDEP. On RV64 (with data in {\tt a0} and
mask in {\tt a1}):

\begin{multicols}{2}
\begin{minipage}{\linewidth}
\begin{verbatim}
  bext64:
    pcntw a2, a1
    bextw a3, a0, a1
    c.srli a0, 32
    c.srli a1, 32
    bextw a0, a0, a1
    sloi a1, zero, 32
    c.and a3, a1
    c.and a0, a1
    sll a0, a2
    c.or a0, a3
    ret
\end{verbatim}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{verbatim}
  bdep64:
    pcntw a2, a1
    bdepw a3, a0, a1
    srl a0, a0, a2
    c.srli a1, 32
    bdepw a0, a0, a1
    c.slli a0, 32
    c.slli a3, 32
    c.srli a3, 32
    c.or a0, a3
    ret
\end{verbatim}
\end{minipage}
\end{multicols}

However, one solution here would be to still reserve the opcode for 64-bit
BEXT/BDEP and leave it to the implementation to decide whether to implement the
function in hardware or emulating it using a software trap.

\section{Analysis of used encoding space}

So how much encoding space is used by the XBitmanip extension?

\begin{table}
\begin{center}
\begin{tabular}{rr|rr|l}
\multicolumn{2}{c|}{RV32} & \multicolumn{2}{c|}{RV64} & Instruction \\
\hline
3x &  0 & 6x &  0 & CLZ, CLZW, CTZ, CTZW, PCNT, PCNTW \\
\hline
1x & 15 & 1x & 15 & GREV \\
2x & 15 & 2x & 16 & GREVI, ZIP \\
\hline
2x & 15 & 6x & 15 & SLO, SRO, SLOW, SROW, SLOIW, SROIW \\
2x & 15 & 2x & 16 & SLOI, SROI \\
\hline
2x & 15 & 5x & 15 & ROR, ROL, RORW, ROLW, RORIW \\
1x & 15 & 1x & 16 & RORI \\
\hline
3x & 15 & 3x & 15 & ANDC, BEXT, BDEP \\
   &    & 2x & 15 & BEXTW, BDEPW \\
\hline
3x &  4 & 3x &  4 & C.NEG, C.NOT, C.BREV \\
\end{tabular}
\end{center}
\caption{XBitmanip encoding space ($log2$, i.e. in equivalent number of bits)}
\label{encspace-tab}
\end{table}

We do not count any encoding space for the unary instructions {\tt clz}, {\tt
clzw}, {\tt ctz}, {\tt ctzw}, {\tt pcnt}, and {\tt pcntw} because they can
be implemented in the reserved modes in {\tt zip}.

The compressed encoding space is $\approx 15.6$ bits wide.

$$ log_2(3 \cdot 2^{14}) \approx 15.585 $$

The compressed XBitmanip instructions need the equivalent of a 5.6 bit
encoding space, or $\approx 0.1\%$ of the total $\approx 15.6$ bits available.

$$ log_2(3 \cdot 2^4) \approx 5.585 $$
$$ 100 / (2^{15.585-5.585}) \approx 0.098 $$

The reserved ``C'' encoding space as of Version 2.2 of the RISC-V User-Level
ISA sim summarized in Table~\ref{resctab}. According to this information
the reserved space is $\approx 11.2$ bits wide. Therefore the compressed
XBitmanip instructions would use $\approx 2.1\%$ of the remaining
reserved ``C'' encoding space.

$$ log_2(2^3-1 + 2^{11} + 2^5 + 2^7 + 2^6 + 1) \approx 11.155 $$
$$ 100 / (2^{11.155-5.585}) \approx 2.105 $$

\begin{table}[h]
\begin{small}
\begin{center}
\begin{tabular}{p{0in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}l}
& & & & & & & & & & \\ &
\instbit{15} &
\instbit{14} &
\instbit{13} &
\multicolumn{1}{c}{\instbit{12}} &
\instbit{11} &
\instbit{10} &
\instbit{9} &
\instbit{8} &
\instbit{7} &
\instbit{6} &
\multicolumn{1}{c}{\instbit{5}} &
\instbit{4} &
\instbit{3} &
\instbit{2} &
\instbit{1} &
\instbit{0} \\
\cline{2-17}
&
\multicolumn{3}{|c|}{000} &
\multicolumn{8}{c|}{0} &
\multicolumn{3}{c|}{nz} &
\multicolumn{2}{c|}{00} & $2^3-1$ \\
\cline{2-17}
&
\multicolumn{3}{|c|}{100} &
\multicolumn{11}{c|}{---} &
\multicolumn{2}{c|}{00} & $2^{11}$ \\
\cline{2-17}
&
\multicolumn{3}{|c|}{011} &
\multicolumn{1}{c|}{0} &
\multicolumn{5}{c|}{---} &
\multicolumn{5}{c|}{0} &
\multicolumn{2}{c|}{01} & $2^5$ \\
\cline{2-17}
&
\multicolumn{3}{|c|}{100} &
\multicolumn{3}{c|}{111} &
\multicolumn{3}{c|}{---} &
\multicolumn{1}{c|}{1} &
\multicolumn{4}{c|}{---} &
\multicolumn{2}{c|}{01} & $2^7$ \\
\cline{2-17}
&
\multicolumn{3}{|c|}{010} &
\multicolumn{1}{c|}{---} &
\multicolumn{5}{c|}{0} &
\multicolumn{5}{c|}{---} &
\multicolumn{2}{c|}{10} & $2^6$ \\
\cline{2-17}
&
\multicolumn{3}{|c|}{100} &
\multicolumn{1}{c|}{0} &
\multicolumn{5}{c|}{0} &
\multicolumn{5}{c|}{0} &
\multicolumn{2}{c|}{10} & $1$ \\
\cline{2-17}
\end{tabular}
\end{center}
\end{small}
\caption{Reserved ``C'' encoding space as of Version 2.2 of the RISC-V User-Level ISA}
\label{resctab}
\end{table}

On RV32, XBitmanip requires the equivalent of a $\approx 18.7$ bit encoding space in
the uncompressed encoding space. For comparison: A single standard I-type
instruction (such as \texttt{ADDI} or \texttt{SLTIU}) requires a $22$ bit
encoding space. I.e. the entire RV32 XBitmanip extension needs less than
one-eighth of the encoding space of the \texttt{SLTIU} instruction.

$$ log_2(13\cdot2^{15}) \approx 18.700 $$

On RV64, XBitmanip requires the equivalent of a $\approx 19.8$ bit encoding
space in the uncompressed encoding space. I.e. the entire RV64 XBitmanip
extension needs about one-quarter of the encoding space of the \texttt{SLTIU}
instruction.

$$ log_2(17\cdot2^{15} + 5\cdot2^{16}) \approx 19.755 $$

\section{Area usage of reference implementations}

\begin{figure}[b]
%%%%%%% BEGIN: verilog/stats.tex %%%%%%%
\begin{center}
\begin{tikzpicture}
\draw[gray!20] (0,-0.119) -- (11.500,-0.119);
\draw[gray!20] (0,-0.238) -- (11.500,-0.238);
\draw[gray!20] (0,-0.356) -- (11.500,-0.356);
\draw[gray!20] (0,-0.475) -- (11.500,-0.475);
\draw[gray!20] (0,-0.594) -- (11.500,-0.594);
\draw[gray!20] (0,0.340) -- (11.500,0.340);
\draw[gray!20] (0,0.680) -- (11.500,0.680);
\draw[gray!20] (0,1.020) -- (11.500,1.020);
\draw[gray!20] (0,1.360) -- (11.500,1.360);
\draw[gray!20] (0,1.700) -- (11.500,1.700);
\draw[gray!20] (0,2.040) -- (11.500,2.040);
\draw[gray!20] (0,2.380) -- (11.500,2.380);
\draw[gray!20] (0,2.720) -- (11.500,2.720);
\draw[gray!20] (0,3.060) -- (11.500,3.060);
\draw[gray!20] (0,3.400) -- (11.500,3.400);
\fill[white] (0,2.5) rectangle (4,4);
\draw[-latex] (0,0) -- (0,4);
\draw (-0.2,4) node[left,rotate=90] {\tiny Logic (LUTs or Gates)};
\draw[-latex] (0,0) -- (0,-1);
\draw (-0.2,-1) node[right,rotate=90] {\tiny FFs};
\draw[pattern=north west lines, pattern color=blue] (0.25,3.5) rectangle (0.5,3.75);
\draw[pattern=crosshatch dots, pattern color=green] (0.25,3.0) rectangle (0.5,3.25);
\draw[pattern=crosshatch, pattern color=magenta] (0.25,2.5) rectangle (0.5,2.75);
\draw (0.5,3.5 + 0.125) node[right] {\tiny ASIC Gates (ror $=$ 458)};
\draw (0.5,3.0 + 0.125) node[right] {\tiny FPGA 4-LUTs (ror $=$ 160)};
\draw (0.5,2.5 + 0.125) node[right] {\tiny D-FFs (ror $=$ 32)};
\draw (0.550,0) node[above right,rotate=90] {\tiny\tt ror};
\fill[white] (0.500,0) rectangle (0.750,0.340);
\fill[white] (0.750,0) rectangle (1.000,0.340);
\fill[white] (0.500,0) rectangle (1.000,-0.119);
\draw[pattern=north west lines, pattern color=blue] (0.500,0) rectangle (0.750,0.340);
\draw[pattern=crosshatch dots, pattern color=green] (0.750,0) rectangle (1.000,0.340);
\draw[pattern=crosshatch, pattern color=magenta] (0.500,0) rectangle (1.000,-0.119);
\draw (1.550,0) node[above right,rotate=90] {\tiny\tt tinygrev};
\fill[white] (1.500,0) rectangle (1.750,0.160);
\fill[white] (1.750,0) rectangle (2.000,0.240);
\fill[white] (1.500,0) rectangle (2.000,-0.160);
\draw[pattern=north west lines, pattern color=blue] (1.500,0) rectangle (1.750,0.160);
\draw[pattern=crosshatch dots, pattern color=green] (1.750,0) rectangle (2.000,0.240);
\draw[pattern=crosshatch, pattern color=magenta] (1.500,0) rectangle (2.000,-0.160);
\draw (2.550,0) node[above right,rotate=90] {\tiny\tt simplegrev};
\fill[white] (2.500,0) rectangle (2.750,0.340);
\fill[white] (2.750,0) rectangle (3.000,0.340);
\fill[white] (2.500,0) rectangle (3.000,-0.119);
\draw[pattern=north west lines, pattern color=blue] (2.500,0) rectangle (2.750,0.340);
\draw[pattern=crosshatch dots, pattern color=green] (2.750,0) rectangle (3.000,0.340);
\draw[pattern=crosshatch, pattern color=magenta] (2.500,0) rectangle (3.000,-0.119);
\draw (3.550,0) node[above right,rotate=90] {\tiny\tt tinygzip};
\fill[white] (3.500,0) rectangle (3.750,0.217);
\fill[white] (3.750,0) rectangle (4.000,0.266);
\fill[white] (3.500,0) rectangle (4.000,-0.156);
\draw[pattern=north west lines, pattern color=blue] (3.500,0) rectangle (3.750,0.217);
\draw[pattern=crosshatch dots, pattern color=green] (3.750,0) rectangle (4.000,0.266);
\draw[pattern=crosshatch, pattern color=magenta] (3.500,0) rectangle (4.000,-0.156);
\draw (4.550,0) node[above right,rotate=90] {\tiny\tt simplegzip};
\fill[white] (4.500,0) rectangle (4.750,0.277);
\fill[white] (4.750,0) rectangle (5.000,0.336);
\fill[white] (4.500,0) rectangle (5.000,-0.119);
\draw[pattern=north west lines, pattern color=blue] (4.500,0) rectangle (4.750,0.277);
\draw[pattern=crosshatch dots, pattern color=green] (4.750,0) rectangle (5.000,0.336);
\draw[pattern=crosshatch, pattern color=magenta] (4.500,0) rectangle (5.000,-0.119);
\draw (5.550,0) node[above right,rotate=90] {\tiny\tt simplebitcnt};
\fill[white] (5.500,0) rectangle (5.750,0.460);
\fill[white] (5.750,0) rectangle (6.000,0.317);
\fill[white] (5.500,0) rectangle (6.000,-0.022);
\draw[pattern=north west lines, pattern color=blue] (5.500,0) rectangle (5.750,0.460);
\draw[pattern=crosshatch dots, pattern color=green] (5.750,0) rectangle (6.000,0.317);
\draw[pattern=crosshatch, pattern color=magenta] (5.500,0) rectangle (6.000,-0.022);
\draw (6.550,0) node[above right,rotate=90] {\tiny\tt simplebfxp};
\fill[white] (6.500,0) rectangle (6.750,0.237);
\fill[white] (6.750,0) rectangle (7.000,0.261);
\fill[white] (6.500,0) rectangle (7.000,-0.119);
\draw[pattern=north west lines, pattern color=blue] (6.500,0) rectangle (6.750,0.237);
\draw[pattern=crosshatch dots, pattern color=green] (6.750,0) rectangle (7.000,0.261);
\draw[pattern=crosshatch, pattern color=magenta] (6.500,0) rectangle (7.000,-0.119);
\draw (7.550,0) node[above right,rotate=90] {\tiny\tt simplebextdep};
\fill[white] (7.500,0) rectangle (7.750,0.586);
\fill[white] (7.750,0) rectangle (8.000,0.663);
\fill[white] (7.500,0) rectangle (8.000,-0.486);
\draw[pattern=north west lines, pattern color=blue] (7.500,0) rectangle (7.750,0.586);
\draw[pattern=crosshatch dots, pattern color=green] (7.750,0) rectangle (8.000,0.663);
\draw[pattern=crosshatch, pattern color=magenta] (7.500,0) rectangle (8.000,-0.486);
\draw (8.550,0) node[above right,rotate=90] {\tiny\tt smartbextdep};
\fill[white] (8.500,0) rectangle (8.750,1.145);
\fill[white] (8.750,0) rectangle (9.000,1.118);
\fill[white] (8.500,0) rectangle (9.000,-0.119);
\draw[pattern=north west lines, pattern color=blue] (8.500,0) rectangle (8.750,1.145);
\draw[pattern=crosshatch dots, pattern color=green] (8.750,0) rectangle (9.000,1.118);
\draw[pattern=crosshatch, pattern color=magenta] (8.500,0) rectangle (9.000,-0.119);
\draw (9.550,0) node[above right,rotate=90] {\tiny\tt XBitmanip};
\fill[white] (9.500,0) rectangle (9.750,2.221);
\fill[white] (9.750,0) rectangle (10.000,2.110);
\fill[white] (9.500,0) rectangle (10.000,-0.379);
\draw[pattern=north west lines, pattern color=blue] (9.500,0) rectangle (9.750,2.221);
\draw[pattern=crosshatch dots, pattern color=green] (9.750,0) rectangle (10.000,2.110);
\draw[pattern=crosshatch, pattern color=magenta] (9.500,0) rectangle (10.000,-0.379);
\draw (10.550,0) node[above right,rotate=90] {\tiny\tt Rocket MulDiv};
\fill[white] (10.500,0) rectangle (10.750,3.697);
\fill[white] (10.750,0) rectangle (11.000,3.066);
\fill[white] (10.500,0) rectangle (11.000,-0.445);
\draw[pattern=north west lines, pattern color=blue] (10.500,0) rectangle (10.750,3.697);
\draw[pattern=crosshatch dots, pattern color=green] (10.750,0) rectangle (11.000,3.066);
\draw[pattern=crosshatch, pattern color=magenta] (10.500,0) rectangle (11.000,-0.445);
\draw (0,0) -- (11.500,0);
\end{tikzpicture}
\end{center}
%%%%%%% END: verilog/stats.tex %%%%%%%
\caption{Relative area of XBitmanip reference cores compared to simple 32-bit rotate
shift and Rocket MulDiv. The height of 1 LUT $\hat{=}$ 2.86 Gates, 1 FF $\hat{=}$ 5.00 Gates.}
\label{area-fig}
\end{figure}

We created RV32 implementations for the different compute cores necessary to
implement XBitmanip (and XBitfield): \url{https://github.com/cliffordwolf/xbitmanip/tree/master/verilog}

We are comparing the area of those cores with the following two references:

\begin{enumerate}
\item A very basic right-rotate shift core ({\tt ror}):
\begin{verbatim}
    module reference_ror (
        input clock,
        input [31:0] din,
        input [4:0] shamt,
        output reg [31:0] dout
    );
        always @(posedge clock)
            dout <= {din, din} >> shamt;
    endmodule
\end{verbatim}
\item A version of the Rocket RV32 {\tt MulDiv} core that performs multiplication
in 5 cycles and division/modulo in 32+ cycles. This is the {\tt MulDiv} default
configuration used in Rocket for small cores.
\end{enumerate}

The implementations of cores performing XBitmanip (and XBitfield) operations are:

\begin{itemize}
\item {\tt tinygrev} --- A small multi-cycle implementation of {\tt grev}/{\tt grevi}.
It takes 6 cycles for one operation.
\item {\tt tinygzip} --- A small multi-cycle implementation of {\tt gzip}.
It takes 5 cycles for one operation.
\item {\tt simplegrev} --- A simple single-cycle implementation of {\tt grev}/{\tt grevi}.
\item {\tt simplegzip} --- A simple single-cycle implementation of {\tt gzip}.
\item {\tt simplebitcnt} --- A simple single-cycle implementation of {\tt clz}, {\tt ctz}, and {\tt pcnt}.
\item {\tt simplebfxp} --- A simple single-cycle implementation of the XBitfield {\tt bfxp}
instruction (see Chapter~\ref{bfxp}). It requires an external rotate-shift implementation.
\item {\tt simplebextdep} --- A straight-forward multi-cycle implementation of {\tt bext}/{\tt bdep}.
It takes up to 32 cycles for one operation (number of set mask bits).
\item {\tt smartbextdep} --- A single-cycle implementation of {\tt bext}/{\tt bdep}
using the method described in~\cite{Hilewitz06}.
\end{itemize}

We implemented those cores with an ASIC cell library containing NOT, NAND, NOR,
AOI3, OAI3, AOI4, and OAI4 gates. For the gate counts below we count NAND and NOR
as 1 gate, NOT as 0.5 gates, AOI3 and OAI3 as 1.5 gates, and AOI4 and OAI4 as 2 gates.

We also implemented the cores using a simple FPGA architecture with 4-LUTs (and no
dedicated CARRY or MUX resources).

\begin{table}[h]
%%%%%%% BEGIN: verilog/stats.tex %%%%%%%
\begin{center}
\begin{tabular}{l|rr|rr|r}
Module & Gates & Depth & 4-LUTs & Depth & FFs \\
\hline
{\tt ror} & 458 & 7 & 160 & 5 & 32 \\
\hline
{\tt tinygrev} & 215 & 5 & 113 & 3 & 43 \\
{\tt simplegrev} & 458 & 7 & 160 & 5 & 32 \\
\hline
{\tt tinygzip} & 292 & 6 & 125 & 4 & 42 \\
{\tt simplegzip} & 373 & 6 & 158 & 4 & 32 \\
\hline
{\tt simplebitcnt} & 619 & 42 & 149 & 13 & 6 \\
\hline
{\tt simplebfxp} & 319 & 13 & 123 & 6 & 32 \\
\hline
{\tt simplebextdep} & 790 & 35 & 312 & 13 & 131 \\
{\tt smartbextdep} & 1542 & 28 & 526 & 10 & 32 \\
\hline
{\tt XBitmanip} & 2992 & 42 & 993 & 13 & 102 \\
{\tt Rocket MulDiv} & 4980 & 53 & 1443 & 24 & 120 \\
\end{tabular}
\end{center}
%%%%%%% END: verilog/stats.tex %%%%%%%
\caption{Area and logic depth of XBitmanip reference cores compared to simple 32-bit rotate
shift and Rocket MulDiv. The entry {\tt XBitmanip} is just the total of {\tt simplegrev} $+$ {\tt
simplegzip} $+$ {\tt simplebitcnt} $+$ {\tt smartbextdep}. Not included in {\tt XBitmanip} is the
cost for adding shift-ones and rotate-shift support to the existing ALU shifter
and the cost for additional decode and control logic.}
\label{area-tab}
\end{table}

Table~\ref{area-tab} and Figure~\ref{area-fig} show the area and logic depth of
our reference cores (and the simple 32-bit rotate shift and Rocket MulDiv for
comparison).

{\tt smartbextdep} could share resources with {\tt simplegrev} (it contains
two butterfly circuits) and {\tt simplebitcnt} (it contains a prefix adder network).
We have not explored those resource sharing options in our reference cores.
