\chapter{RISC-V XBitmanip Extension}

In the proposals provided in this section, the C code examples are for
illustration purposes. They are not optimal implementations, but are
intended to specify the desired functionality.

The sections on encodings are mere placeholders.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Count Leading/Trailing Zeros (\texttt{clz, ctz})}

The {\tt clz} operation counts the number of 0 bits before the first 1 bit
(counting from the most significant bit) in the source register. This is
related to the ``integer logarithm''. It takes a single register as
input and operates on the entire register. If the input is 0, the output is
XLEN. If the input is \textasciitilde{}0, the output is 0.

The {\tt ctz} operation counts the number of 0 bits after the last 1 bit.
If the input is 0, the output is XLEN. If the input is \textasciitilde{}0,
the output is 0.

\begin{verbatim}
uint_xlen_t clz(uint_xlen_t rs1)
{
    for (int count = 0; count < XLEN; count++)
        if ((rs1 << count) >> (XLEN-1))
            return count;
    return XLEN;
}

uint_xlen_t ctz(uint_xlen_t rs1)
{
    for (int count = 0; count < XLEN; count++)
        if ((rs1 >> count) & 1)
            return count;
    return XLEN;
}
\end{verbatim}

\input{bextclz.tex}

One possible encoding for \texttt{clz} and \texttt{ctz} is as standard I-type opcodes
somewhere in the brownfield surrounding the shift-immediate instructions.

% \subsection{Related Pseudo-instructions}
%
% The common operation of `finding the index of the highest bit set' (also called
% \texttt{ilog2} or \texttt{bsr} or \texttt{find\ last\ set}) is computed as
% \texttt{XLEN-clz(rs1)}.
%
% Counting trailing zeros is easily implemented by combining \texttt{clz} with
% the \texttt{grevi} instruction.
%
% \subsection{Criteria}
%
% The criteria evaluation is shown below:
%
% \begin{itemize}
% \item
%   These operations all fit easily into the RISCV instruction encoding
%   and philosophy.
% \item
%   The hardware to implement them is fairly simple, and can be done in a
%   logarithmic number of stages in parallel.
% \item
%   They all have current compiler and standard library support, and are
%   standardized intrinsics in many of those.
% \item
%   The threshold criteria gets a little complicated: Every one of these
%   operations can be implemented in 2-3 instructions in terms of
%   each-other, so we only need one of them in hardware, and the rest can
%   be pseudo-instructions.
% \end{itemize}
%
% However, implementing any of these instructions can also be done with a
% combination of \texttt{ctz} and a bitwise reverse (\texttt{brev}) in 1-2
% instructions. Similarly, \texttt{ctz} can be implemented in terms of
% these functions with a \texttt{brev} in 1-2 instructions.
%
% Without \texttt{brev} AND \texttt{ctz}, however, there is no simple way
% to construct this without a lot of instructions. The algorithm above in
% C is a nearly asymptotically optimal implementation. It seems to pass
% the threshold criteria in this case.
%
% \paragraph{Benchmarks and Applications}
%
% TBD
%
% \subsection{References}
%
% https://en.wikipedia.org/wiki/Find\_first\_set\#CLZ
%
% https://fgiesen.wordpress.com/2013/10/18/bit-scanning-equivalencies/

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Count Bits Set (\texttt{pcnt})}

The purpose of this instruction is to compute the number of 1 bits in a
register. It takes a single register as input and operates on the entire
register.

This operation counts the total number of set bits in the register.

\begin{verbatim}
uint_xlen_t pcnt(uint_xlen_t rs1)
{
    int count = 0;
    for (int index = 0; index < XLEN; index++)
        count += (rs1 >> index) & 1;
    return count;
}
\end{verbatim}

\input{bextpcnt.tex}

One possible encoding for \texttt{pcnt} is as a standard I-type opcode somewhere
in the brownfield surrounding the shift-immediate instructions.

% Implementation Commentary
%
% \texttt{pcnt} can be implemented in parallel, similarly to an adder.
%
% \subsection{Related Pseudo-Instructions}
%
% \begin{verbatim}
% //odd parity
% parity rOut,rIn:
%     pcnt rPopulation,rIn
%     andi rOut,rPopulation,0x1
% \end{verbatim}
%
% \subsection{Extensions: \texttt{pcnt.w} (R64I+), \texttt{pcnt.d} (R128I+)}
%
% On RV64B+, the appropriate versions of pcnt that operate on sub-portions
% of the register are defined. On these platforms, the input source is set
% to zero for the high portions of the register. See \texttt{addi.w} and
% \texttt{addi.d} in the R64I/R128I specifications.
%
% \subsection{Justification}
%
% This operation is one of the `core' bitwise instructions that is nearly
% universal on other ISAs. It is supported as an intrinsic on GCC, LLVM,
% and MSVC, and is supported in hardware on a plethora of platforms.
%
% \subsection{References}
%
% https://en.wikipedia.org/wiki/Hamming\_weight
%
% https://graphics.stanford.edu/\textasciitilde{}seander/bithacks.html

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Generalized Reverse (\texttt{grev,\ grevi})}

The purpose of this instruction is to provide a single hardware
instruction that can implement all of byte-order swap, bitwise reversal,
short-order-swap, word-order-swap (RV64I), nibble-order swap, bitwise
reversal in a byte, etc, all from a single hardware instruction. It
takes in a single register value and an immediate that controls which
function occurs, through controlling the levels in the recursive tree at
which reversals occur.

This operation iteratively checks each bit immed\_i from i=0 to XLEN-1,
in XLEN stages, and if the corresponding bit of the `function\_select'
immediate is true for the current stage, swaps each adjacent pair of
2\^{}i bits in the register.

\texttt{grevi} `butterfly' implementation in C on various architectures

\begin{verbatim}
uint32_t grev32(uint32_t rs1, int32_t rs2)
{
    uint32_t x = rs1;
    if (rs2 &  1) x = ((x & 0x55555555) << 1) | ((x & 0xAAAAAAAA) >> 1);
    if (rs2 &  2) x = ((x & 0x33333333) << 2) | ((x & 0xCCCCCCCC) >> 2);
    if (rs2 &  4) x = ((x & 0x0F0F0F0F) << 4) | ((x & 0xF0F0F0F0) >> 4);
    if (rs2 &  8) x = ((x & 0x00FF00FF) << 8) | ((x & 0xFF00FF00) >> 8);
    if (rs2 & 16) x = ((x & 0x0000FFFF) <<16) | ((x & 0xFFFF0000) >> 16);
    return x;
}

uint64_t grev64(uint32_t rs1, int32_t rs2)
{
    uint64_t x = rs1;
    if (rs2 &  1) x = ((x & 0x5555555555555555) << 1) | ((x & 0xAAAAAAAAAAAAAAAA) >> 1);
    if (rs2 &  2) x = ((x & 0x3333333333333333) << 2) | ((x & 0xCCCCCCCCCCCCCCCC) >> 2);
    if (rs2 &  4) x = ((x & 0x0F0F0F0F0F0F0F0F) << 4) | ((x & 0xF0F0F0F0F0F0F0F0) >> 4);
    if (rs2 &  8) x = ((x & 0x00FF00FF00FF00FF) << 8) | ((x & 0xFF00FF00FF00FF00) >> 8);
    if (rs2 & 16) x = ((x & 0x0000FFFF0000FFFF) <<16) | ((x & 0xFFFF0000FFFF0000) >> 16);
    if (rs2 & 32) x = ((x & 0x00000000FFFFFFFF) <<32) | ((x & 0xFFFFFFFF00000000) >> 32);
    return x;
}
\end{verbatim}

The above pattern should be intuitive to understand in order to extend
this definition in an obvious manner for RV128+.

\input{bextgrev.tex}

\texttt{grev} is encoded as standard R-type opcode and \texttt{grevi} is
encoded as standard I-type opcode.

% \subsection{Related Pseudo-Instructions}
%
% Related Pseudoinstruction List
%
% \begin{verbatim}
% // reverse the bits in a register (this works on all platforms)
% rev rOut,rIn:
%     grevi rOut,rIn,-1
%
% // reverse the bits in each byte, but leave the bytes in the same order.
% rev.b rOut,rIn:
%     grevi rOut,rIn,7
%
% // reverse the bits in each halfword, but leave the halfwords in the same order
% rev.h rOut,rIn:
%     grevi rOut,rIn,15
%
% // reverse the bits in each word, but leave the words in the same order (e.g. RV64IB+)
% rev.w rOut,rIn:
%     grevi rOut,rIn,31
%
% // reverse the bits in each dword, but leave the dwords in the same order (e.g. RV128IB+)
% rev.d rOut,rIn:
%     grevi rOut,rIn,63
%
% // reverse the byte order of an entire register
% bswap rOut,rIn:
%     grevi rOut,rIn,-8
%
% // reverse the byte order of each halfword in the register, but leave them in the same
% // order (e.g, on RV32IB, this reverses the byte order of the high and lo halfwords)
% bswap.h rOut,rIn:
%     grevi rOut,rIn,8
%
% // reverse the byte order each word in the register (e.g, on RV64IB/RV128IB, this
% // reverses the byte order of each of the 2/4 words)
% bswap.w rOut,rIn:
%     grevi rOut,rIn,24
%
% // reverse the byte order of each dword in the register (e.g, on RV128IB, reverse the
% // byte order of the high and lo words)
% bswap.d rOut,rIn:
%     grevi rOut,rIn,56
%
% // reverse the halfword order of an entire register
% hswap rOut,rIn:
%     grevi rOut,rIn,-16
%
% // reverse the halfword order of each word in the register
% hswap.w rOut,rIn:
%     grevi rOut,rIn,16
%
% // reverse the halfword order of each dword in the register (e.g. RV128IB+, there are 2
% // dwords)
% hswap.d rOut,rIn:
%     grevi rOut,rIn,48
%
% // reverse the word order of an entire register (only meaningful on RV64IB+)
% wswap rOut,rIn:
%     grevi rOut,rIn,-32
%
% // reverse the word order of each dword in the register (e.g. RV128IB+, there are 2 dwords)
% wswap.d rOut,rIn:
%     grevi rOut,rIn,32
%
% // swap the nibbles of each byte in the whole register (useful for converting to/from
% // bigendian hex)
% nswap.b rOut,rIn:
%     grevi rOut,rIn,4
%
% // Etc.  A total of XLEN different possible operations can be constructed.
% \end{verbatim}
%
% \subsection{Justification}
%
% Quoted from page 102 of Hacker's Delight:
%
% https://books.google.com/books?id=iBNKMspIlqEC\&lpg=PP1\&pg=RA1-SL20-PA2\#v=onepage\&q\&f=false
%
% \begin{quote}
% For k=31, this operation reverses the bits in a word. For k=24, it
% reverses the bytes in a word. For k=7, it reverses the bits in each
% byte, without changing the positions of the bytes. For k=16, it swaps
% the left and right halfwords of a word, and so on. In general, it moves
% the bit at positing m to position m XOR k. It can be implemented in
% hardware very similarly to the way a rotate shifter is usually
% implemented (five stages of MUX, with each stage controlled by a bit of
% the shift amount k)
%
% This strongly suggests that this generic instruction could allow us to
% use a great deal of other bitwise operations as pseudo-instructions.
% \end{quote}
%
% \subsection{References}
%
% Hackers Delight, Chapter 7.1, ``Generalized Bit Reversal'' in
%
% https://books.google.com/books?id=iBNKMspIlqEC\&lpg=PP1\&pg=RA1-SL20-PA2\#v=onepage\&q\&f=false
%
% http://hackersdelight.org/

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Shift Ones (Left/Right) (\texttt{slo,\ sloi,\ sro,\ sroi})}

These instructions are similar to shift-logical operations from the base
spec, except instead of shifting in zeros, it shifts in ones. This can
be used in mask creation or bit-field insertions, for example.

These instructions are exactly the same as the equivalent logical shift
operations, except the shift shifts in ones values.

\begin{verbatim}
uint_xlen_t slo(uint_xlen_t rs1, uint_xlen_t rs2)
{
    int shamt = rs2 & (XLEN-1);
    return ~(~rs1 << shamt);
}

uint_xlen_t sro(uint_xlen_t rs1, uint_xlen_t rs2)
{
    int shamt = rs2 & (XLEN-1);
    return ~(~rs1 >> shamt);
}
\end{verbatim}

\input{bextsxo.tex}

\texttt{s(l/r)o(i)} is encoded similarly to the logical shifts in the
base spec. However, the spec of the entire family of instructions is
changed so that the high bit of the instruction indicates the value to
be inserted during a shift. This means that a \texttt{sloi} instruction
can be encoded similarly to an \texttt{slli} instruction, but with a 1
in the highest bit of the encoded instruction. This encoding is
backwards compatible with the definition for the shifts in the base
spec, but allows for simple addition of a ones-insert.

When implementing this circuit, the only change in the ALU over a
standard logical shift is that the value shifted in is not zero, but is
a 1-bit register value that has been forwarded from the high bit of the
instruction decode. This creates the desired behavior on both logical
zero-shifts and logical ones-shifts.

% \subsection{Extensions: \texttt{s(l/r)o(i).w} (R64I+), \texttt{s(l/r)o(i).d} (R128I+)}
%
% On RV64B+, the appropriate versions of shift-ones that operate on
% sub-portions of the register are defined. On these platforms, the input
% source is set to zero for the high portions of the register, and the
% shift only occurs on the lower portions of the register. See
% \texttt{slli.w} and \texttt{slli.d} in the R64I/R128I specifications.
% See \texttt{slli.w} and \texttt{slli.d} in the R64I/R128I
% specifications.
%
% \subsection{Related Pseudo-Instructions}
%
% \begin{verbatim}
% // builds a mask in the low-order bits up to a certain point
% maski rOut,iWidth:
%     sloi rOut,r0,iWidth
%
% // builds a mask in the low-order bits up to a certain point
% mask rOut,rIn:
%     slo rOut,r0,rIn
%
% // extracts a bitfield of length width from offset and moves it down to the bottom
% bfextracti rOut,rIn,iWidth,iOffset:
%     slli rTop,rIn,XLEN-iWidth-iOffset
%     srli rOut,rTop,XLEN-iWidth
%
% // updates a bitfield of length width at offset in rCurrent with the value from rIn
% bfupdatei rOut,rCurrent,rIn,iWidth,iOffset:
%     sloi rTop,rIn,<XLEN-iWidth>
%     sroi rField,rTop,<XLEN-iWidth-iOffset>
%     and rOut,rCurrent,rField
%
% // sets a bitfield of length-width at offset to 1
% bfseti rOut,rCurrent,iWidth,iOffset:
%     sloi rMask,r0,iWidth
%     slli rMask,rMask,iOffset
%     or rOut,rCurrent,rMask
%
% // sets a bitfield of length-width at offset to 0
% bfcleari rOut,rCurrent,iWidth,iOffset:
%     sloi rMask,r0,iWidth
%     slli rMask,rMask,iOffset
%     andc rOut,rCurrent,rMask
% \end{verbatim}
%
% \subsection{Justification}
%
% This instruction can be used to create masks, which is an incredibly
% common operation for modifying the bitfield structures.
%
% \subsection{References}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Rotate (Left/Right) (\texttt{rol,\ ror,\ rori})}

These instructions are similar to shift-logical operations from the base
spec, except they shift in the values from the opposite side of the
register, in order. This is also called `circular shift'.

\begin{verbatim}
uint_xlen_t rol(uint_xlen_t rs1, uint_xlen_t rs2)
{
    int shamt = rs2 & (XLEN-1);
    return (rs1 << shamt) | (rs1 >> (XLEN-shamt));
}

uint_xlen_t ror(uint_xlen_t rs1, uint_xlen_t rs2)
{
    int shamt = rs2 & (XLEN-1);
    return (rs1 >> shamt) | (rs1 << (XLEN-shamt));
}
\end{verbatim}

\input{bextrox.tex}

Rotate shift is implemented very similarly to the other shift
instructions. One possible way to encode it is to re-use the way that
bit 30 in the instruction encoding selects `arithmetic shift' when bit
31 is zero (signalling a logical-zero shift). We can re-use this so that
when bit 31 is set (signalling a logical-ones shift), if bit 31 is also
set, then we are doing a rotate. The following table summarizes the
behavior. The generalized reverse opcodes can be encoded using the
bit pattern that would otherwise encode an ``Arithmetic Left Shift''
(which is an operation that does not exist).

\begin{longtable}[c]{@{}lll@{}}
\caption{Rotate Encodings}\tabularnewline
\toprule
Bit 31 & Bit 30 & Meaning\tabularnewline
\midrule
\endfirsthead
\toprule
Bit 31 & Bit 30 & Meaning\tabularnewline
\midrule
\endhead
0 & 0 & Logical Shift-Zeros\tabularnewline
0 & 1 & Arithmetic Shift\tabularnewline
1 & 0 & Logical Shift-Ones\tabularnewline
1 & 1 & Rotate\tabularnewline
\bottomrule
\end{longtable}

% Implementation Commentary
%
% \subsection{Extensions: \texttt{ro(r/l)(i).w} (R64I+),\texttt{ro(r/l)(i).d} (R128I+)}
%
% On RV64B+, the appropriate versions of rotate that operate on
% sub-portions of the register are defined. On these platforms, the input
% source is set to zero for the high portions of the register, and the
% shift only occurs on the lower portions of the register. See
% \texttt{slli.w} and \texttt{slli.d} in the R64I/R128I specifications.
%
% \subsection{Justification}
%
% This instruction is very useful for cryptography, hashing, and other
% operations.
%
% \subsection{References}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{And-with-complement (\texttt{andc})}

This instruction implements the and-with-complement operation.

\begin{verbatim}
uint_xlen_t andc(uint_xlen_t rs1, uint_xlen_t rs2)
{
    return rs1 & ~rs2;
}
\end{verbatim}

Other with-complement operations ({\tt orc, nand, nor}, etc) can be implemented
by combining {\tt not} ({\tt c.not}) with the base ALU operation. (Which can
fit in 32 bit when using two compressed instructions.) Only and-with-complement
occurs frequently enough to warrant a dedicated instruction.

\input{bextandc.tex}

% \subsection{Related Pseudo-Instructions}
%
% \begin{verbatim}
% // this selects the corresponding bit from the two arguments A and B, based on
% // whether or not Control is high.
% // out[i] = Control[i] ? A[i] : B[i]
% mix rOut,rControl,rA,rB:
%     and rTmp,rA,rControl
%     andc rTmp2,rB,rControl
%     or rOut,rTmp,rTmp2
%
% // same as MIX but only use if the first bit of C is true (as in from a comparator)
% // C can only be zero or 1, so if you need a SGT to implement nonzero comparator
% // its 5 instructions in total.
% mux rOut,rControl,rA,rB:
%     neg rC2,rControl
%     and rTmp,rA,rC2
%     andc rTmp2,rB,rC2
%     or rOut,rTmp,rTmp2
% \end{verbatim}
%
% \subsection{Justification}
%
% http://svn.clifford.at/handicraft/2017/bitcode/
%
% \subsection{References}
%
% http://www.hackersdelight.org/basics2.pdf

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Bit Extract/Deposit (\texttt{bext,\ bdep})}

This instructions implement the generic bit extract and bit deposit functions.
This operation is also referred to as bit gather/scatter, bit pack/unpack,
parallel extract/deposit, compress/expand, or right\_compress/right\_expand.

\texttt{BEXT[W] rd,rs1,rs2} collects LSB justified bits to rd from
rs1 using extract mask in rs2.

\texttt{BDEP[W] rd,rs1,rs2} writes LSB justified bits from rs1 to rd using
deposit mask in rs2.

\begin{verbatim}
uint_xlen_t bext(uint_xlen_t v, uint_xlen_t mask)
{
    uint_xlen_t c = 0, m = 1;
    while (mask) {
        uint_xlen_t b = mask & -mask;
        if (v & b)
            c |= m;
        mask -= b;
        m <<= 1;
    }
    return c;
}

uint_xlen_t bdep(uint_xlen_t v, uint_xlen_t mask)
{
    uint_xlen_t c = 0, m = 1;
    while (mask) {
        uint_xlen_t b = mask & -mask;
        if (v & m)
            c |= b;
        mask -= b;
        m <<= 1;
    }
    return c;
}
\end{verbatim}

Implementations might chose to use smaller multi-cycle implementations of
\texttt{bext} and \texttt{bdep}. Even though multi-cycle \texttt{bext} and
\texttt{bdep} often are not fast enough to outperform algortihms that use
sequences of shifts and bit masks, dedicated instructions for those operations
can still be of great advantage, especially in cases where the mask argument
is not constant.

For example, the following code efficiently calculates the index of the tenth
set bit in {\tt a0} using \texttt{bdep}:

\begin{verbatim}
  li a1, 0x00000200
  bdep a0, a1, a0
  brev a0, a0
  clz a0, a0
\end{verbatim}

For cases with a constant mask an optimizing compiler would decide when to use
\texttt{bext} or \texttt{bdep} based on the optimization profile for the
concrete processor it is optimizing for. This is similar to the decision
whether to use MUL or DIV with a constant, or to perform the same operation
using a longer sequence of much simpler operations.

\input{bextscagat.tex}

% \subsection{Related Pseudo-Instructions}
%
% TBD
%
% \subsection{Justification}
%
% http://svn.clifford.at/handicraft/2017/permsyn/
%
% \subsection{References}
%
% http://programming.sirrida.de/bit\_perm.html\#gather\_scatter
%
% Hackers Delight, Chapter 7.1, ``Compress, Generalized Extract'' in
%
% https://books.google.com/books?id=iBNKMspIlqEC\&lpg=PP1\&pg=RA1-SL20-PA2\#v=onepage\&q\&f=false
%
% http://hackersdelight.org/
%
% https://github.com/cliffordwolf/bextdep

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Generalized Bit Permutations (\texttt{shuffle})}

This instruction performs a bit permutation on the value in rs1. Which bit permutation
is performed is defined by the control word in rs2 (Table~\ref{shuffle-ctrl}).

\begin{table}[h]
\begin{small}
\begin{center}
\begin{tabular}{p{0.1in}p{0.5in}p{0.5in}p{0.5in}p{0.5in}p{0.5in}p{0.5in}p{0.2in}p{0.2in}p{0.05in}p{0.05in}l}
& & & & & & & & & & & \\
\multicolumn{1}{r}{\instbit{64}} &
\multicolumn{1}{l}{\instbit{63}} &
\multicolumn{1}{r}{\instbit{48}} &
\multicolumn{1}{l}{\instbit{47}} &
\multicolumn{1}{r}{\instbit{32}} &
\multicolumn{1}{l}{\instbit{31}} &
\multicolumn{1}{r}{\instbit{16}} &
\multicolumn{1}{l}{\instbit{15}} &
\multicolumn{1}{r}{\instbit{12}} &
\multicolumn{1}{l}{\instbit{11}} &
\multicolumn{1}{r}{\instbit{0}} & \\
\cline{1-11}

\multicolumn{1}{c}{} &
\multicolumn{4}{c}{mask} &
\multicolumn{2}{c|}{} &
\multicolumn{2}{c|}{mode} &
\multicolumn{2}{c|}{command} & RV128 \\
\cline{1-11}

& \multicolumn{2}{|c|}{unused} &
\multicolumn{4}{c|}{mask} &
\multicolumn{2}{c|}{mode} &
\multicolumn{2}{c|}{command} & RV64 \\
\cline{2-11}

& & & & &
\multicolumn{2}{|c|}{mask} &
\multicolumn{2}{c|}{mode} &
\multicolumn{2}{c|}{command} & RV32 \\
\cline{6-11}

\end{tabular}
\end{center}
\end{small}
\caption{\texttt{shuffle} control word}
\label{shuffle-ctrl}
\end{table}

This spec only defines command $=$ 0. Non-zero command values are reserved for
future use.  An implementation that does not support a given command must
return 0 in rd. Support for command 0 is mandatory. Command values 1-7 are
reserved for non-standard extensions (NSE).

Command 0 implements functions that are required for computing zip and unzip
operations, butterfly stages or entire butterfly networks, omega stages or networks, flip
stages or network, and similar operations. Table~\ref{shuffle-modes} lists the
operations performed by command 0. Note that this functions can all use the
existing butterfly network that implements the GREV instructions.

\begin{table}[h]
\begin{small}
\begin{center}
\begin{tabular}{l l l}
Mode & Description & Pseudo instructions \\ \hline

0000 & zip + butterfly(mask, 0)                    & {\tt omega, zip} \\
0001 & zip4 + butterfly(mask, 0)                   & {\tt omega, zip} \\
0010 & zip8 + butterfly(mask, 0)                   & {\tt omega, zip} \\
0011 & zip16 + butterfly(mask, 0)                  & {\tt omega, zip} \\
0100 & butterfly(mask, 0) + unzip                  & {\tt flip, unzip} \\
0101 & butterfly(mask, 0) + unzip4                 & {\tt flip, unzip} \\
0110 & butterfly(mask, 0) + unzip8                 & {\tt flip, unzip} \\
0111 & butterfly(mask, 0) + unzip16                & {\tt flip, unzip} \\

\hline

1000 & butterfly(mask, 0)                          & {\tt bfly} \\
1001 & butterfly(mask, 1)                          & {\tt bfly} \\
1010 & butterfly(mask, 2)                          & {\tt bfly} \\
1011 & butterfly(mask, 3)                          & {\tt bfly} \\
1100 & butterfly(mask, 4)                          & {\tt bfly} \\
1101 & butterfly(mask, 5) (RV64/128; NSE)          & {\tt bfly} \\
1110 & butterfly(mask, 6) (RV128; NSE)             & {\tt bfly} \\
1111 & reserved for future standard extensions     & --- \\

\end{tabular}
\end{center}
\end{small}
\caption{Modes for shuffle command 0}
\label{shuffle-modes}
\end{table}

Modes that are reserved for future standard or non-standard extensions must return
0 in rd on implementations that do not support those future extensions.

\texttt{shuffle} with rs2$=$0 (x0) implements just a zip operation (butterfly is
disabled because mask$=$0).

The \texttt{zip} (aka ``shuffle'') operation interleaves the bits of the lower and upper
half of its argument. The \texttt{unzip} (aka ``unshuffle'') operation performs the inverse.

In other words, \texttt{zip} performs a rotate left shift on the bit indices,
and \texttt{unzip} performs a rotate right shift on the bit indices.
Performing \texttt{zip} $log_2(\textrm{XLEN})$ times is the identity. Performing it
$log_2(\textrm{XLEN})-1$ times is equivalent to one execution of \texttt{unzip}.

\begin{verbatim}
uint_xlen_t zip(uint_xlen_t rs1)
{
    uint_xlen_t x = 0;
    for (int i = 0; i < XLEN/2; i++) {
        x |= ((rs1 >> i) & 1) << (2*i);
        x |= ((rs1 >> (i+XLEN/2)) & 1) << (2*i+1);
    }
    return x;
}

uint_xlen_t unzip(uint_xlen_t rs1)
{
    uint_xlen_t x = 0;
    for (int i = 0; i < XLEN/2; i++) {
        x |= ((rs1 >> (2*i)) & 1) << i;
        x |= ((rs1 >> (2*i+1)) & 1) << (i+XLEN/2);
    }
    return x;
}
\end{verbatim}

The operations \texttt{zip4}, \texttt{zip8}, and \texttt{zip16} perform a zip on each nibble,
byte, and half-word of the argument and \texttt{unzip4}, \texttt{unzip8}, and \texttt{unzip16}
perform the unzip operation on each nibble, byte, and half-word of the argument. (A zip or
unzip on a 2-bit unit is just a zero-order butterfly. On RV64 the SHUFFLEW command can be used
to perform a zip or unzip on the lower 32 bits of a register.)

The butterfly operation performs a single butterfly stage N (i.e. the {\tt grev} operation
with argument $2^N$), which performs $\textrm{XLEN}/2$ pairwise bit swaps. But unlike
{\tt grev} the individual bit swaps are conditional and the $\textrm{XLEN}/2$
bits in mask determine which bit swaps are taken.

\begin{verbatim}
uint_xlen_t swapbits(uint_xlen_t x, int p, int q)
{
    assert(p < q);
    x = x ^ ((x & (1 << p)) << (q-p));
    x = x ^ ((x & (1 << q)) >> (q-p));
    x = x ^ ((x & (1 << p)) << (q-p));
    return x;
}

uint_xlen_t butterfly(uint_xlen_t x, uint_xlen_t mask, int N)
{
    int a = 1 << N, b = 2*a;
    for (int i = 0; i < XLEN/2; i++) {
        int p = b*(i/a) + i%a, q = p + a;
        if ((mask >> i) & 1)
            x = swapbits(x, p, q);
    }
    return x;
}
\end{verbatim}

Putting it all together:

\begin{verbatim}
uint_xlen_t shuffle(uint_xlen_t x, uint_xlen_t ctrl)
{
    uint_xlen_t mask = ctrl >> 16;
    int mode = (ctrl >> 12) & 15;
    int cmd = ctrl & 0xfff;

    if (cmd != 0 || mode > 7+LOG2_XLEN)
        return 0;

    if (mode == 0)
        return butterfly(zip(x), mask, 0);

    if (mode == 1)
        return unzip(butterfly(x, mask, 0));

    if (mode > 7)
        return butterfly(x, mask, mode & 7);

    return 0;
}
\end{verbatim}

On RV32, a control word for command 0 can be loaded using a single \texttt{lui} instruction.
At most $2\cdot{}log_2(\textrm{XLEN})-1$ shuffle operations are required to
perform an arbitrary bit permutation. Most bit permutations that arise from
real-world applications can be implemented in shorter sequences.

Commands in the range 1-2047 with the upper bits (mask/mode) set to zero can be
loaded with a single \texttt{li} instruction. Note that there is no
requirement for future non-zero commands to perform bit-permutations or even
reversible operations.

\input{bextshuffle.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Compressed instructions (\texttt{c.not,\ c.neg,\ c.brev})}

The RISC-V ISA has no dedicated instructions for bitwise inverse (\texttt{not})
and arithmetic inverse (\texttt{neg}). Instead \texttt{not} is implemented as
\texttt{xori\ rd,\ rs,\ -1} and \texttt{neg} is implemented as
\texttt{sub\ rd,\ x0,\ rs}.

In bitmanipulation code \texttt{not} and \texttt{neg} are very common operations. But
there are no compressed encodings for those operations because there is no \texttt{c.xori}
instruction and \texttt{c.sub} can not operate on \texttt{x0}.

Many bit manipulation operations that have dedicated opecodes in other ISAs
must be constructed from smaller atoms in RISC-V XBitmanip code. But
implementations might chose to implement them in a single micro-op using
macro-op-fusion. For this it can be helpful when the fused sequences are short.
\texttt{not} and \texttt{neg} are good candidates for macro-op-fusion, so
it can be helpful to have compressed opcodes for them.

Likewise \texttt{brev} (an alias for \texttt{grevi\ rd,\ rs,\ -1}, i.e. bitwise
reversal) is also a very common atom for building bit manipulation operations. So it
is helpful to have a compressed opcode for this instruction as well.

The compressed instructions \texttt{c.not,\ c.neg,\ c.brev} must be supported by
all implementations that support the C extension and XBitmanip.

\input{bextcompr}

This three instructions fit nicely in the reserved space in C.LUI/C.ADDI16SP.
They only occupy $0.1\%$ of the $\approx15.6$ bits wide RVC encoding space.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Pseudo instructions and macros}

RISC-V is a RISC instruction set. Unless there is a good argument against it, we try not
to assign dedicated opcodes for complex operations that are just easily macro-op fusable
short sequences of already existing instructions, especially if compressed instructions
can be used to keep the length of those sequences reasonably short.

The assembler should provide pseudo-instructions for some of the sequences that
are implemented using dedicated instructions in some CISC bit-maniuplation instruction
sets. The sections describing sequences where the assembler should provide pseudo-instructions
are titled ``pseudo instruction'', whereas sections that just informally describe useful
sequences are titles ``macro''.

Many of the code snippets below can utilize compressed instructions. But for simplicity
we use uncompressed instructions in the assembler listings. Some of the macros
spill to temporary registers. {\tt t0, t1, t2, \dots} is used for spilling in the
assembler listings. The input register are referred to by {\tt rs1, rs2, \dots} and
the output register is {\tt rd}.

\subsection{MIX/MUX Macros}

\subsubsection{MIX Operation}

A MIX operation selects bits from {\tt rs1} and {\tt rs2} based on the bits in
the control word {\tt rs3}.

\begin{verbatim}
  and t0, rs1, rs3
  andc t1, rs2, rs3
  or rd, t0, t1
\end{verbatim}

\subsubsection{MUX Operation}

A MUX operation selects word {\tt rs1} or {\tt rs2} based on if the control
word {\tt rs3} is zero or nonzero, without branching.

\begin{verbatim}
  snez t0, rs3
  neg t0, t0
  and t1, rs1, t0
  andc t2, rs2, t0
  or rd, t1, t2
\end{verbatim}

Or when {\tt rs3} is already either 0 or 1:

\begin{verbatim}
  neg t0, rs3
  and t1, rs1, t0
  andc t2, rs2, t0
  or rd, t1, t2
\end{verbatim}

\subsection{Bit-field extract and deposit}

\subsubsection{Pseudo instruction {\tt bfext}}

Extract the continous bit field starting at {\tt pos} with length {\tt len}
from {\tt rs}:

\begin{verbatim}
  bfext rd, rs, pos, len   ->   slli rd, rs, (XLEN-po-len)
                                srli rd, rd, (XLEN-len)
\end{verbatim}

\subsubsection{Macros for bit-field deposit}

Deposit {\tt len} bits from {\tt rs2} at {\tt pos} in {\tt rd}, remaining bits
in {\tt rd} are filled from {\tt rs1}.

Assuming {\tt rs1[pos+len-1:pos]}$=$0 and {\tt rs2[XLEN-1:pos]}$=$0:

\begin{verbatim}
  slli t0, rs2, pos
  or rd, rs1, t0
\end{verbatim}

Otherwise masking and/or shift operations should be used to clear the extra
bits in {\tt rs1} and {\tt rs2} first. On a machine with fast {\tt bdep},
the {\tt bdep} instruction can be used to shift and mask {\tt rs2} in one
instruction using at the same mask that is also used to mask {\tt rs1}:

\begin{verbatim}
  li t0, ((1 << len)-1) << pos
  andc t1, rs1, t0
  bdep t0, rs2, t0
  or rd, t0, t1
\end{verbatim}

\subsection{Pseudo instructions using {\tt grevi}}

On RV32:

\begin{verbatim}
  brev    rd, rs   ->    grevi rd, rs, 31    ; bitwise reverse
  brev.h  rd, rs   ->    grevi rd, rs, 15    ; reverse bits in each 16 bit half-word
  brev.b  rd, rs   ->    grevi rd, rs,  7    ; reverse bits in each  8 bit byte

  bswap   rd, rs   ->    grevi rd, rs, 24    ; reverse the byte order
  bswap.h rd, rs   ->    grevi rd, rs,  8    ; swap bytes in each 16 bit half-word

  hswap   rd, rs   ->    grevi rd, rs, 16    ; swap the two 16 bit half-words
\end{verbatim}

On RV64:

\begin{verbatim}
  brev    rd, rs   ->    grevi rd, rs, 63    ; bitwise reverse
  brev.w  rd, rs   ->    grevi rd, rs, 31    ; reverse bits in each 32 bit word
  brev.h  rd, rs   ->    grevi rd, rs, 15    ; reverse bits in each 16 bit half-word
  brev.b  rd, rs   ->    grevi rd, rs,  7    ; reverse bits in each  8 bit byte

  bswap   rd, rs   ->    grevi rd, rs, 56    ; reverse the byte order
  bswap.w rd, rs   ->    grevi rd, rs, 24    ; reverse byte order in each 32 bit word
  bswap.h rd, rs   ->    grevi rd, rs,  8    ; swap bytes in each 16 bit half-word

  hswap   rd, rs   ->    grevi rd, rs, 48    ; reverse order of 16 bit half-words
  hswap.w rd, rs   ->    grevi rd, rs, 16    ; swap 16 bit half-words in each 32 bit word

  wswap   rd, rs   ->    grevi rd, rs, 32    ; swap the two 32 bit words
\end{verbatim}

\subsection{Pseudo instructions using {\tt shuffle}}

\subsubsection{Pseudo instruction {\tt bfly}}

{\tt shuffle} with mode[3]$=$1 (and mode[2:0] $<$ $log_2(\textrm{XLEN})$) performs
a butterfly operation. The assembler should provide a {\tt bfly} pseudo-instruction
for rd $\neq$ rs and constant {\tt mask} and {\tt N} (if {\tt N} is omitted then
{\tt N}$=$0 is assumed):

\begin{verbatim}
  bfly rd, rs, mask[, N]     ->     lui rd, ((mask << 4) | 8 | N)
                                    shuffle rd, rs, rd
\end{verbatim}

(On RV64, longer sequences are required instead of {\tt lui} to load the full
32 bit mask into {\tt rd}.)

For example, an arbitrary RV32 bit permutation using a complete butterfly network:

\begin{verbatim}
  bfly a1, a0, <maskA>, 4
  bfly a2, a1, <maskB>, 3
  bfly a0, a2, <maskC>, 2
  bfly a1, a0, <maskD>, 1
  bfly a2, a1, <maskE>, 0
  bfly a0, a2, <maskF>, 1
  bfly a1, a0, <maskG>, 2
  bfly a2, a1, <maskH>, 3
  bfly a0, a2, <maskI>, 4
\end{verbatim}

Permutations arising from real-world applications can often be implemented using
shorter sequences.

\subsubsection{Pseudo instructions {\tt omega} and {\tt flip}}

A zip operation followed by a butterfly(0) is commonly known as an {\it omega stage}.

An unzip operation followed by butterfly($\log_2(\textrm{XLEN})-1$)) (or
equivialently, butterfly(0) followed by unzip) is commonly known as a {\it flip
stage}. The assember should provide appropiate pseudo-instructions for rd
$\neq$ rs and constant {\tt mask}:

\begin{verbatim}
  omega rd, rs, mask          ->     lui rd, (mask << 4)
                                     shuffle rd, rs, rd

  flip  rd, rs, mask          ->     lui rd, ((mask << 4) | 1)
                                     shuffle rd, rs, rd
\end{verbatim}

For example, an arbitrary RV32 bit permutation using a complete omega-flip network:

\begin{verbatim}
  omega a1, a0, <maskA>
  omega a0, a1, <maskB>
  omega a1, a0, <maskC>
  omega a0, a1, <maskD>
  omega a1, a0, <maskE>
  flip  a0, a1, <maskF>
  flip  a1, a0, <maskG>
  flip  a0, a1, <maskH>
  flip  a1, a0, <maskI>
  flip  a0, a1, <maskJ>
\end{verbatim}

Or one instruction shorter by merging the center omega+flip pair into a
butterfly operation:

\begin{verbatim}
  omega a1, a0, <maskA>
  omega a2, a1, <maskB>
  omega a0, a2, <maskC>
  omega a1, a0, <maskD>
  bfly  a2, a1, <maskE> ^ <maskF>, 4
  flip  a0, a2, <maskG>
  flip  a1, a0, <maskH>
  flip  a2, a1, <maskI>
  flip  a0, a2, <maskJ>
\end{verbatim}

As for butterfly networks, permutations arising from real-world applications
can often be implemented using a much shorter sequence. Especially if {\tt bfly},
{\tt omega} and {\tt flip} can be mixed arbitrarily.

\subsubsection{Pseudo instructions {\tt zip} and {\tt unzip}}

With a zero value as control word, {\tt shuffle} performs a simple zip
operation. The assembler should provide an according pseudo-instruction:

\begin{verbatim}
  zip rd, rs      ->     shuffle rd, rs, zero
\end{verbatim}

And for rd $\neq$ rs:

\begin{verbatim}
  unzip rd, rs    ->     lui rd, 1
                         shuffle rd, rs, rd
\end{verbatim}

The \texttt{zip} instruction with the upper half of its input cleared performs
the commonly needed ``fan-out'' operation. (Equivalent to {\tt bdep} with a
0x55555555 mask.) The \texttt{zip} instruction applied twice fans out the bits
in the lower quarter of the input word by a spacing of 4 bits.

For example, the following code calculates the bitwise prefix sum of the bits
in the lower byte of a 32 bit word on RV32:

\begin{verbatim}
  andi a0, a0, 0xff
  zip a0, a0
  zip a0, a0
  slli a1, a0, 4
  add a0, a1
  slli a1, a0, 8
  add a0, a1
  slli a1, a0, 16
  add a0, a1
\end{verbatim}

The final prefix sum is stored in the 8 nibbles of the {\tt a0} output word.
