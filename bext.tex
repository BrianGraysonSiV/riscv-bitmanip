\chapter{RISC-V XBitmanip Extension}

In the proposals provided in this section, the C code examples are for
illustration purposes. They are not optimal implementations, but are
intended to specify the desired functionality.

The sections on encodings are mere placeholders.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Count Leading/Trailing Zeros (\texttt{clz, ctz})}

The {\tt clz} operation counts the number of 0 bits before the first 1 bit
(counting from the most significant bit) in the source register. This is
related to the ``integer logarithm''. It takes a single register as input and
operates on the entire register. If the input is 0, the output is XLEN. If the
input is -1, the output is 0.

The {\tt ctz} operation counts the number of 0 bits after the last 1 bit.  If
the input is 0, the output is XLEN. If the input is -1, the output is 0.

\input{bextcref-clz-ctz}

\input{bextclz.tex}

One possible encoding for \texttt{clz} and \texttt{ctz} is as standard I-type opcodes
somewhere in the brownfield surrounding the shift-immediate instructions.

% \subsection{References}
%
% https://en.wikipedia.org/wiki/Find\_first\_set\#CLZ
%
% https://fgiesen.wordpress.com/2013/10/18/bit-scanning-equivalencies/

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Count Bits Set (\texttt{pcnt})}

This instruction computes the number of 1 bits in a register. It takes a single
register as input and operates on the entire register.

This operation counts the total number of set bits in the register.

\input{bextcref-pcnt}

\input{bextpcnt.tex}

One possible encoding for \texttt{pcnt} is as a standard I-type opcode somewhere
in the brownfield surrounding the shift-immediate instructions.

% \subsection{Related Pseudo-Instructions}
%
% \begin{verbatim}
% //odd parity
% parity rOut,rIn:
%     pcnt rPopulation,rIn
%     andi rOut,rPopulation,0x1
% \end{verbatim}
%
% \subsection{References}
%
% https://en.wikipedia.org/wiki/Hamming\_weight
%
% https://graphics.stanford.edu/\textasciitilde{}seander/bithacks.html

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{And-with-complement (\texttt{andc})}

This instruction implements the and-with-complement operation.

\input{bextcref-andc}

Other with-complement operations ({\tt orc, nand, nor}, etc) can be implemented
by combining {\tt not} ({\tt c.not}) with the base ALU operation. (Which can
fit in 32 bit when using two compressed instructions.) Only and-with-complement
occurs frequently enough to warrant a dedicated instruction.

\input{bextandc.tex}

% \subsection{Justification}
%
% http://svn.clifford.at/handicraft/2017/bitcode/
%
% \subsection{References}
%
% http://www.hackersdelight.org/basics2.pdf

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Shift Ones (Left/Right) (\texttt{slo,\ sloi,\ sro,\ sroi})}

These instructions are similar to shift-logical operations from the base
spec, except instead of shifting in zeros, it shifts in ones. This can
be used in mask creation or bit-field insertions, for example.

These instructions are exactly the same as the equivalent logical shift
operations, except the shift shifts in ones values.

\input{bextcref-sxo}

\input{bextsxo.tex}

\texttt{s(l/r)o(i)} is encoded similarly to the logical shifts in the
base spec. However, the spec of the entire family of instructions is
changed so that the high bit of the instruction indicates the value to
be inserted during a shift. This means that a \texttt{sloi} instruction
can be encoded similarly to an \texttt{slli} instruction, but with a 1
in the highest bit of the encoded instruction. This encoding is
backwards compatible with the definition for the shifts in the base
spec, but allows for simple addition of a ones-insert.

When implementing this circuit, the only change in the ALU over a
standard logical shift is that the value shifted in is not zero, but is
a 1-bit register value that has been forwarded from the high bit of the
instruction decode. This creates the desired behavior on both logical
zero-shifts and logical ones-shifts.

% \subsection{Extensions: \texttt{s(l/r)o(i).w} (R64I+), \texttt{s(l/r)o(i).d} (R128I+)}
%
% On RV64B+, the appropriate versions of shift-ones that operate on
% sub-portions of the register are defined. On these platforms, the input
% source is set to zero for the high portions of the register, and the
% shift only occurs on the lower portions of the register. See
% \texttt{slli.w} and \texttt{slli.d} in the R64I/R128I specifications.
% See \texttt{slli.w} and \texttt{slli.d} in the R64I/R128I
% specifications.
%
% \subsection{Related Pseudo-Instructions}
%
% \begin{verbatim}
% // builds a mask in the low-order bits up to a certain point
% maski rOut,iWidth:
%     sloi rOut,r0,iWidth
%
% // builds a mask in the low-order bits up to a certain point
% mask rOut,rIn:
%     slo rOut,r0,rIn
%
% // extracts a bitfield of length width from offset and moves it down to the bottom
% bfextracti rOut,rIn,iWidth,iOffset:
%     slli rTop,rIn,XLEN-iWidth-iOffset
%     srli rOut,rTop,XLEN-iWidth
%
% // updates a bitfield of length width at offset in rCurrent with the value from rIn
% bfupdatei rOut,rCurrent,rIn,iWidth,iOffset:
%     sloi rTop,rIn,<XLEN-iWidth>
%     sroi rField,rTop,<XLEN-iWidth-iOffset>
%     and rOut,rCurrent,rField
%
% // sets a bitfield of length-width at offset to 1
% bfseti rOut,rCurrent,iWidth,iOffset:
%     sloi rMask,r0,iWidth
%     slli rMask,rMask,iOffset
%     or rOut,rCurrent,rMask
%
% // sets a bitfield of length-width at offset to 0
% bfcleari rOut,rCurrent,iWidth,iOffset:
%     sloi rMask,r0,iWidth
%     slli rMask,rMask,iOffset
%     andc rOut,rCurrent,rMask
% \end{verbatim}
%
% \subsection{Justification}
%
% This instruction can be used to create masks, which is an incredibly
% common operation for modifying the bitfield structures.
%
% \subsection{References}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Rotate (Left/Right) (\texttt{rol,\ ror,\ rori})}

These instructions are similar to shift-logical operations from the base
spec, except they shift in the values from the opposite side of the
register, in order. This is also called `circular shift'.

\input{bextcref-rox}

\input{bextrox.tex}

Rotate shift is implemented very similarly to the other shift
instructions. One possible way to encode it is to re-use the way that
bit 30 in the instruction encoding selects `arithmetic shift' when bit
31 is zero (signalling a logical-zero shift). We can re-use this so that
when bit 31 is set (signalling a logical-ones shift), if bit 31 is also
set, then we are doing a rotate. The following table summarizes the
behavior. The generalized reverse opcodes can be encoded using the
bit pattern that would otherwise encode an ``Arithmetic Left Shift''
(which is an operation that does not exist).

\begin{longtable}[c]{@{}lll@{}}
\caption{Rotate Encodings}\tabularnewline
\toprule
Bit 31 & Bit 30 & Meaning\tabularnewline
\midrule
\endfirsthead
\toprule
Bit 31 & Bit 30 & Meaning\tabularnewline
\midrule
\endhead
0 & 0 & Logical Shift-Zeros\tabularnewline
0 & 1 & Arithmetic Shift\tabularnewline
1 & 0 & Logical Shift-Ones\tabularnewline
1 & 1 & Rotate\tabularnewline
\bottomrule
\end{longtable}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[t]
\begin{center}
\input{bextcref-printperm-rot}
\end{center}
\caption{\texttt{rot} permutation network}
\label{permnet-rot}
\end{figure}

\section{Generalized Reverse (\texttt{grev,\ grevi})}

This instruction provides a single hardware instruction that can implement all
of byte-order swap, bitwise reversal, short-order-swap, word-order-swap
(RV64), nibble-order swap, bitwise reversal in a byte, etc, all from a single
hardware instruction. It takes in a single register value and an immediate that
controls which function occurs, through controlling the levels in the recursive
tree at which reversals occur.

This operation iteratively checks each bit $i$ in rs2 from $i=0$ to
$\textrm{XLEN}-1$, and if the corresponding bit is set, swaps each adjacent
pair of $2^i$ bits.

\begin{figure}[t]
\begin{center}
\input{bextcref-printperm-grev}
\end{center}
\caption{\texttt{grev} permutation network}
\label{permnet-grev}
\end{figure}

\input{bextcref-grev}

The above pattern should be intuitive to understand in order to extend
this definition in an obvious manner for RV128.

The {\tt grev} operation can easily be implemented using a permutation
network with $log_2(\textrm{XLEN})$ stages. Figure~\ref{permnet-rot}
shows the permutation network for {\tt rot} for reference.
Figure~\ref{permnet-grev} shows the permutation network for {\tt grev}.

\input{bextgrev.tex}

\texttt{grev} is encoded as standard R-type opcode and \texttt{grevi} is
encoded as standard I-type opcode. \texttt{grev} and \texttt{grevi} can
use the instruction encoding for ``arithmetic shift left''.

% \subsection{References}
%
% Hackers Delight, Chapter 7.1, ``Generalized Bit Reversal'' in
%
% https://books.google.com/books?id=iBNKMspIlqEC\&lpg=PP1\&pg=RA1-SL20-PA2\#v=onepage\&q\&f=false
%
% http://hackersdelight.org/

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Generalized zip/unzip (\texttt{gzip})}
\label{gzip}

{\tt gzip} is the third bit permutation instruction in XBitmanip, after {\tt rori}
and {\tt grevi}.

The {\tt gzip} instruction uses an I-type encoding similar to {\tt grevi}.
There are XLEN different generalized zip operations, some of which are reserved
because they are no-ops, or equivalent to other modes, or encode for obscure
combinations of other modes. The bit pattern for the non-reserved modes
match the regular expression {\tt /\^{}0*(10+|11+0*[01])\$/}.
See Table~\ref{gzip-modes}.

Reserving modes that encode for ``obscure combinations of other modes'' can help
implementations that use different base permutations (or completely different
mechanisms) to implement the {\tt gzip} instruction. The reserved modes can be
used to encode unary functions such as {\tt ctz}, {\tt clz}, and {\tt pcnt}.

\begin{table}[h]
\begin{small}
\begin{center}
\begin{tabular}{c l l}
      mode   & Bit index rotations               & Pseudo-Instruction \\ \hline

\sout{0000 0} & no-op                            & {\it reserved} \\
\sout{0000 1} & no-op                            & {\it reserved} \\
      0001 0  & {\tt i[1] -> i[0]}               & {\tt zip.n, unzip.n} \\
\sout{0001 1} & {\it equivalent to 0001 0}       & {\it reserved} \\
      0010 0  & {\tt i[2] -> i[1]}               & {\tt zip2.b, unzip2.b} \\
\sout{0010 1} & {\it equivalent to 0010 0}       & {\it reserved} \\
      0011 0  & {\tt i[2] -> i[0]}               & {\tt zip.b} \\
      0011 1  & {\tt i[2] <- i[0]}               & {\tt unzip.b} \\

\hline

      0100 0  & {\tt i[3] -> i[2]}               & {\tt zip4.h, unzip4.h} \\
\sout{0100 1} & {\it equivalent to 0100 0}       & {\it reserved} \\
\sout{0101 0} & {\tt i[3] -> i[2], i[1] -> i[0]} & {\it reserved} \\
\sout{0101 1} & {\it equivalent to 0101 0}       & {\it reserved} \\
      0110 0  & {\tt i[3] -> i[1]}               & {\tt zip2.h} \\
      0110 1  & {\tt i[3] <- i[1]}               & {\tt unzip2.h} \\
      0111 0  & {\tt i[3] -> i[0]}               & {\tt zip.h} \\
      0111 1  & {\tt i[3] <- i[0]}               & {\tt unzip.h} \\

\hline

      1000 0  & {\tt i[4] -> i[3]}               & {\tt zip8, unzip8} \\
\sout{1000 1} & {\it equivalent to 1000 0}       & {\it reserved} \\
\sout{1001 0} & {\tt i[4] -> i[3], i[1] -> i[0]} & {\it reserved} \\
\sout{1001 1} & {\it equivalent to 1001 0}       & {\it reserved} \\
\sout{1010 0} & {\tt i[4] -> i[3], i[2] -> i[1]} & {\it reserved} \\
\sout{1010 1} & {\it equivalent to 1010 0}       & {\it reserved} \\
\sout{1011 0} & {\tt i[4] -> i[3], i[2] -> i[0]} & {\it reserved} \\
\sout{1011 1} & {\tt i[4] <- i[3], i[2] <- i[0]} & {\it reserved} \\

\hline

      1100 0  & {\tt i[4] -> i[2]}               & {\tt zip4} \\
      1100 1  & {\tt i[4] <- i[2]}               & {\tt unzip4} \\
\sout{1101 0} & {\tt i[4] -> i[2], i[1] -> i[0]} & {\it reserved} \\
\sout{1101 1} & {\tt i[4] <- i[2], i[1] <- i[0]} & {\it reserved} \\
      1110 0  & {\tt i[4] -> i[1]}               & {\tt zip2} \\
      1110 1  & {\tt i[4] <- i[1]}               & {\tt unzip2} \\
      1111 0  & {\tt i[4] -> i[0]}               & {\tt zip} \\
      1111 1  & {\tt i[4] <- i[0]}               & {\tt unzip} \\
\end{tabular}
\end{center}
\end{small}
\caption{RV32 modes for {\tt gzip} instruction}
\label{gzip-modes}
\end{table}

\begin{figure}[t]
\begin{center}
\input{bextcref-printperm-gzip-noflip}
\end{center}
\caption{\texttt{gzip} permutation network without ``flip'' stages}
\label{permnet-gzip-noflip}
\end{figure}

Like GREV and rotate shift, the {\tt gzip} instruction can be implemented using a short
sequence of atomic permutations, that are enabled or disabled by the mode (shamt)
bits. But zip has one stage fewer than GREV and the LSB bit of mode controls the order
in which the stages are applied:

\input{bextcref-gzip32}

Alternatively {\tt gzip} can be implemented in a single network with one more
stage than GREV, with the additional first and last stage executing a
permutation that effectively reverses the order of the inner stages. However,
since the inner stages only mux half of the bits in the word each, a hardware
implementation using this additional ``flip'' stages might actually be more
expensive than simply creating two networks.

\input{bextcref-gzip32-alt}

Figure~\ref{permnet-gzip-flip} shows the {\tt gzip} permutation network with
``flip'' stages and Figure~\ref{permnet-gzip-noflip} shows the {\tt gzip}
permutation network without ``flip'' stages.

\begin{figure}[t]
\begin{center}
\input{bextcref-printperm-gzip-flip}
\end{center}
\caption{\texttt{gzip} permutation network with ``flip'' stages}
\label{permnet-gzip-flip}
\end{figure}

The \texttt{zip} instruction with the upper half of its input cleared performs
the commonly needed ``fan-out'' operation. (Equivalent to {\tt bdep} with a
0x55555555 mask.) The \texttt{zip} instruction applied twice fans out the bits
in the lower quarter of the input word by a spacing of 4 bits.

For example, the following code calculates the bitwise prefix sum of the bits
in the lower byte of a 32 bit word on RV32:

\begin{verbatim}
  andi a0, a0, 0xff
  zip a0, a0
  zip a0, a0
  slli a1, a0, 4
  add a0, a1
  slli a1, a0, 8
  add a0, a1
  slli a1, a0, 16
  add a0, a1
\end{verbatim}

The final prefix sum is stored in the 8 nibbles of the {\tt a0} output word.

\input{bextgzip}

There is no R-type instruction for {\tt gzip}. It is an I-type only instruction.
\texttt{gzip} can use the instruction encoding for ``rotate left immediate''.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Bit Extract/Deposit (\texttt{bext,\ bdep})}

This instructions implement the generic bit extract and bit deposit functions.
This operation is also referred to as bit gather/scatter, bit pack/unpack,
parallel extract/deposit, compress/expand, or right\_compress/right\_expand.

\texttt{BEXT rd,rs1,rs2} collects LSB justified bits to rd from
rs1 using extract mask in rs2.

\texttt{BDEP rd,rs1,rs2} writes LSB justified bits from rs1 to rd using
deposit mask in rs2.

\input{bextcref-bext}

Implementations might choose to use smaller multi-cycle implementations of
\texttt{bext} and \texttt{bdep}. Even though multi-cycle \texttt{bext} and
\texttt{bdep} often are not fast enough to outperform algortihms that use
sequences of shifts and bit masks, dedicated instructions for those operations
can still be of great advantage in cases where the mask argument is not
constant.

For example, the following code efficiently calculates the index of the tenth
set bit in {\tt a0} using \texttt{bdep}:

\begin{verbatim}
  li a1, 0x00000200
  bdep a0, a1, a0
  ctz a0, a0
\end{verbatim}

For cases with a constant mask an optimizing compiler would decide when to use
\texttt{bext} or \texttt{bdep} based on the optimization profile for the
concrete processor it is optimizing for. This is similar to the decision
whether to use MUL or DIV with a constant, or to perform the same operation
using a longer sequence of much simpler operations.

\input{bextscagat.tex}

% \subsection{Justification}
%
% http://svn.clifford.at/handicraft/2017/permsyn/
%
% \subsection{References}
%
% http://programming.sirrida.de/bit\_perm.html\#gather\_scatter
%
% Hackers Delight, Chapter 7.1, ``Compress, Generalized Extract'' in
%
% https://books.google.com/books?id=iBNKMspIlqEC\&lpg=PP1\&pg=RA1-SL20-PA2\#v=onepage\&q\&f=false
%
% http://hackersdelight.org/
%
% https://github.com/cliffordwolf/bextdep
%
% http://palms.ee.princeton.edu/system/files/Hilewitz_JSPS_08.pdf

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Compressed instructions (\texttt{c.not,\ c.neg,\ c.brev})}

The RISC-V ISA has no dedicated instructions for bitwise inverse (\texttt{not})
and arithmetic inverse (\texttt{neg}). Instead \texttt{not} is implemented as
\texttt{xori\ rd,\ rs,\ -1} and \texttt{neg} is implemented as
\texttt{sub\ rd,\ x0,\ rs}.

In bitmanipulation code \texttt{not} and \texttt{neg} are very common operations. But
there are no compressed encodings for those operations because there is no \texttt{c.xori}
instruction and \texttt{c.sub} can not operate on \texttt{x0}.

Many bit manipulation operations that have dedicated opcodes in other ISAs
must be constructed from smaller atoms in RISC-V XBitmanip code. But
implementations might choose to implement them in a single micro-op using
macro-op-fusion. For this it can be helpful when the fused sequences are short.
\texttt{not} and \texttt{neg} are good candidates for macro-op-fusion, so
it can be helpful to have compressed opcodes for them.

Likewise \texttt{brev} (an alias for \texttt{grevi\ rd,\ rs,\ -1}, i.e. bitwise
reversal) is also a very common atom for building bit manipulation operations. So it
is helpful to have a compressed opcode for this instruction as well.

The compressed instructions \texttt{c.not,\ c.neg,\ c.brev} must be supported by
all implementations that support the C extension and XBitmanip.

\input{bextcompr}

This three instructions fit nicely in the reserved space in C.LUI/C.ADDI16SP.
They only occupy $0.1\%$ of the $\approx15.6$ bits wide RVC encoding space.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Pseudo instructions and macros}

RISC-V is a RISC instruction set. Unless there is a good argument against it, we try not
to assign dedicated opcodes for complex operations that are just easily macro-op fusable
short sequences of already existing instructions, especially if compressed instructions
can be used to keep the length of those sequences reasonably short.

The assembler should provide pseudo-instructions for some of the sequences that
are implemented using dedicated instructions in some CISC bit-maniuplation instruction
sets. The sections describing sequences where the assembler should provide pseudo-instructions
are titled ``pseudo instruction'', whereas sections that just informally describe useful
sequences are titles ``macro''.

Many of the code snippets below can utilize compressed instructions. But for simplicity
we use uncompressed instruction mnemonics in the assembler listings. Some of the macros
spill to temporary registers. {\tt t0, t1, t2, \dots} is used for spilling in the
assembler listings. The input register are referred to by {\tt rs1, rs2, \dots} and
the output register is {\tt rd}.

\subsection{MIX/MUX Macros}

\subsubsection{MIX Operation}

A MIX operation selects bits from {\tt rs1} and {\tt rs2} based on the bits in
the control word {\tt rs3}.

\begin{verbatim}
  and t0, rs1, rs3
  andc t1, rs2, rs3
  or rd, t0, t1
\end{verbatim}

\subsubsection{MUX Operation}

A MUX operation selects word {\tt rs1} or {\tt rs2} based on if the control
word {\tt rs3} is zero or nonzero, without branching.

\begin{verbatim}
  snez t0, rs3
  neg t0, t0
  and t1, rs1, t0
  andc t2, rs2, t0
  or rd, t1, t2
\end{verbatim}

Or when {\tt rs3} is already either 0 or 1:

\begin{verbatim}
  neg t0, rs3
  and t1, rs1, t0
  andc t2, rs2, t0
  or rd, t1, t2
\end{verbatim}

\subsection{Bit-field extract and deposit}

\subsubsection{Pseudo instruction {\tt bfext}}

Extract the continous bit field starting at {\tt pos} with length {\tt len}
from {\tt rs}:

\begin{verbatim}
  bfext rd, rs, pos, len   ->   slli rd, rs, (XLEN-po-len)
                                srli rd, rd, (XLEN-len)
\end{verbatim}

\subsubsection{Macros for bit-field deposit}

Deposit {\tt len} bits from {\tt rs2} at {\tt pos} in {\tt rd}, remaining bits
in {\tt rd} are filled from {\tt rs1}.

Assuming {\tt rs1[pos+len-1:pos]}$=$0 and {\tt rs2[XLEN-1:pos]}$=$0:

\begin{verbatim}
  slli t0, rs2, pos
  or rd, rs1, t0
\end{verbatim}

Otherwise masking and/or shift operations should be used to clear the extra
bits in {\tt rs1} and {\tt rs2} first. On a machine with fast {\tt bdep},
the {\tt bdep} instruction can be used to shift and mask {\tt rs2} in one
instruction using at the same mask that is also used to mask {\tt rs1}:

\begin{verbatim}
  li t0, ((1 << len)-1) << pos
  andc t1, rs1, t0
  bdep t0, rs2, t0
  or rd, t0, t1
\end{verbatim}

\subsection{Pseudo instructions for bit scanning and counting}

\subsubsection{Pseudo instructions for counting leading/trailing ones}

\begin{verbatim}
  clo rd, rs   ->   not rd, rs
                    clz rd, rd

  cto rd, rs   ->   not rd, rs
                    ctz rd, rd
\end{verbatim}

\subsubsection{Pseudo instruction for counting bits cleared}

\begin{verbatim}
  pcntn rd, rs   ->   not rd, rs
                      pcnt rd, rd
\end{verbatim}

\subsubsection{Pseudo instructions for parity}

Odd parity:

\begin{verbatim}
  oparity rd, rs   ->   pcnt rd, rs
                        andi rd, rd, 1
\end{verbatim}

Even parity:

\begin{verbatim}
  eparity rd, rs   ->   pcnt rd, rs
                        addi rd, rd, 1
                        andi rd, rd, 1
\end{verbatim}

\subsection{Pseudo instructions using {\tt grevi}}

On RV32:

\begin{verbatim}
  brev    rd, rs   ->    grevi rd, rs, 31    ; bitwise reverse
  brev.h  rd, rs   ->    grevi rd, rs, 15    ; reverse bits in each 16 bit half-word
  brev.b  rd, rs   ->    grevi rd, rs,  7    ; reverse bits in each  8 bit byte

  bswap   rd, rs   ->    grevi rd, rs, 24    ; reverse the byte order
  bswap.h rd, rs   ->    grevi rd, rs,  8    ; swap bytes in each 16 bit half-word

  hswap   rd, rs   ->    grevi rd, rs, 16    ; swap the two 16 bit half-words
\end{verbatim}

On RV64:

\begin{verbatim}
  brev    rd, rs   ->    grevi rd, rs, 63    ; bitwise reverse
  brev.w  rd, rs   ->    grevi rd, rs, 31    ; reverse bits in each 32 bit word
  brev.h  rd, rs   ->    grevi rd, rs, 15    ; reverse bits in each 16 bit half-word
  brev.b  rd, rs   ->    grevi rd, rs,  7    ; reverse bits in each  8 bit byte

  bswap   rd, rs   ->    grevi rd, rs, 56    ; reverse the byte order
  bswap.w rd, rs   ->    grevi rd, rs, 24    ; reverse byte order in each 32 bit word
  bswap.h rd, rs   ->    grevi rd, rs,  8    ; swap bytes in each 16 bit half-word

  hswap   rd, rs   ->    grevi rd, rs, 48    ; reverse order of 16 bit half-words
  hswap.w rd, rs   ->    grevi rd, rs, 16    ; swap 16 bit half-words in each 32 bit word

  wswap   rd, rs   ->    grevi rd, rs, 32    ; swap the two 32 bit words
\end{verbatim}

\subsection{Macros for bit permutations}

\subsubsection{Butterfly operations}

The following macro performs a stage-{\tt N} butterfly operation on the word in
{\tt a0} using the mask in {\tt a1}.

\begin{verbatim}
  grevi t0, a0, (1 << N)
  and t0, t0, a1
  andc a0, a0, a1
  or a0, a0, t0
\end{verbatim}

The bitmask in {\tt a1} must be preformatted correctly for the selected butterfly
stage. A butterfly operation only has a XLEN/2 wide control word. The following
macros format the mask assuming those XLEN/2 bits in the lower half of {\tt a1}
on entry (preformatted mask in {\tt a1} on exit):

\begin{verbatim}
bfly_msk_0:
  zip a1, a1
  slli t0, a1, 1
  or a1, a1, t0

bfly_msk_1:
  zip2 a1, a1
  slli t0, a1, 2
  or a1, a1, t0

bfly_msk_2:
  zip4 a1, a1
  slli t0, a1, 4
  or a1, a1, t0

...
\end{verbatim}

A sequence of $2\cdot{}log_2(\textrm{XLEN})-1$ butterfly operations can perform any
arbitrary bit permutation (Bene{\v s} network):

\begin{verbatim}
  butterfly(LOG2_XLEN-1)
  butterfly(LOG2_XLEN-2)
  ...
  butterfly(0)
  ...
  butterfly(LOG2_XLEN-2)
  butterfly(LOG2_XLEN-1)
\end{verbatim}


Many permutations arising from real-world applications can be implemented
using shorter sequences. For example, any sheep-and-goats operation with either
the sheep or the goats bit reversed can be implemented in $log_2(\textrm{XLEN})$
butterfly operations.

Reversing a permutation implemented using butterfly operations is as simple as
reversing the order of butterfly operations.

% References
% http://www.princeton.edu/~rblee/PUpapers/xiao_spie00.pdf
% https://www.lirmm.fr/arith18/papers/hilewitz-PerformingBitManipulations.pdf
% https://pdfs.semanticscholar.org/bcd0/8fdccf3d5ab959fd81162bd811706ba1676a.pdf

\subsubsection{Omega-Flip Networks}

The omega operation is a stage-0 butterfly preceeded by a zip operation:

\begin{verbatim}
  zip a0, a0
  grevi t0, a0, 1
  and t0, t0, a1
  andc a0, a0, a1
  or a0, a0, t0
\end{verbatim}

The flip operation is a stage-0 butterfly followed by an unzip operation:

\begin{verbatim}
  grevi t0, a0, 1
  and t0, t0, a1
  andc a0, a0, a1
  or a0, a0, t0
  unzip a0, a0
\end{verbatim}

A sequence of $log_2(\textrm{XLEN})$ omega operations followed by
$log_2(\textrm{XLEN})$ flip operations can implement any arbitrary 32 bit
permutation.

As for butterfly networks, permutations arising from real-world applications
can often be implemented using a shorter sequence.

% References
% https://ieeexplore.ieee.org/document/878264/
% https://www.princeton.edu/~rblee/ELE572Papers/lee_slideshotchips2002.pdf

\subsubsection{Baseline Networks}

Another way of implementing arbitrary 32 bit permutations is using a
baseline network followed by an inverse baseline network.

A baseline network is a sequence of $log_2(\textrm{XLEN})$ butterfly(0)
operations interleaved with unzip operations. For example, a 32-bit
baseline network:

\begin{verbatim}
  butterfly(0)
  unzip
  butterfly(0)
  unzip.h
  butterfly(0)
  unzip.b
  butterfly(0)
  unzip.n
  butterfly(0)
\end{verbatim}

An inverse baseline network is a sequence of $log_2(\textrm{XLEN})$ butterfly(0)
operations interleaved with zip operations. The order is opposite to the
order in a baseline network. For example, a 32-bit inverse baseline network:

\begin{verbatim}
  butterfly(0)
  zip.n
  butterfly(0)
  zip.b
  butterfly(0)
  zip.h
  butterfly(0)
  zip
  butterfly(0)
\end{verbatim}

A baseline network followed by an inverse baseline network can implement
any arbitrary bit permutation.

% References
% https://dl.acm.org/citation.cfm?id=1311797

\subsubsection{Sheep-and-goats operation}

The Sheep-and-goats (SAG) operation is a common operation for bit permutations.
It moves all the bits selected by a mask (goats) to the LSB end of the word
and all the remaining bits (sheeps) to the MSB end of the word, without changing
the order of sheeps or goats.

The SAG operation can easily be performed using {\tt bext} (data in {\tt a0} and
mask in {\tt a1}):

\begin{verbatim}
  bext t0, a0, a1
  not a1, a1
  bext a0, a0, a1
  pcnt a1, a1
  ror a0, a0, a1
  or a0, a0, t0
\end{verbatim}

Any arbitrary bit permutation can be implement in $log_2(\textrm{XLEN})$ SAG
operations.

{\it The Hacker's Delight} describes an optimized standard C implementation of
the SAG operation. Their algorithm takes 254 instructions (for 32 bit) or 340
instructions (for 64 bit) on their reference RISC instruction set.

% References
% Knuth
% Hackers Delight, Chapter 7-7
