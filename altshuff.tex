\chapter{Alternative to \texttt{shuffle} instruction}

There are a couple of issues with the {\tt shuffle} instruction as currently proposed.

(1) It performs a fairly complex operation (the description of the instruction
spans 4 pages).

(2) It tries to do two things at the same time, namely perform various zip/unzip
operations and perform butterfly operations of different orders.

(3) Even though all butterfly stages should be present in a GREV unit, tapping into
those stages to inject the masks for {\tt shuffle} increases overall complexity of
the core.

(4) Implementing a butterfly+mask operation can easily be done with grevi, zip,
and the mix pattern (and+andc+or).

This chapter proposes to replace the {\tt shuffle} instruction with a generalized
{\tt zip} instruction with an encoding similar to {\tt grevi}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Generalized zip/unzip (\texttt{gzip})}
\label{gzip}

{\it Under construction}

{\tt gzip} is the third bit permutation instruction in XBitmanip, after {\tt rori}
and {\tt grevi}.

The {\tt gzip} instruction uses an I-type encoding similar to {\tt grevi}.
There are XLEN different generalized zip operations, some of which are reserved
because they are no-ops, or equivalent to other modes, or encode for obscure
combinations of other modes. The bit pattern for the non-reserved modes
match the regular expression {\tt /\^{}0*(10+|11+0*[01])\$/}.
See Table~\ref{gzip-modes}.

Reserving modes that encode for ``obscure combinations of other modes'' can help
implementations that use different base permutations (or completely different
mechanisms) to implement the {\tt gzip} instruction. The reserved modes can be
used to encode unary functions such as {\tt ctz}, {\tt clz}, and {\tt pcnt}.

\begin{table}[h]
\begin{small}
\begin{center}
\begin{tabular}{c l l}
      mode   & Bit index rotations               & Instruction \\ \hline

\sout{0000 0} & no-op                            & {\it reserved} \\
\sout{0000 1} & no-op                            & {\it reserved} \\
      0001 0  & {\tt i[1] -> i[0]}               & {\tt zip.n, unzip.n} \\
\sout{0001 1} & {\it equivalent to 0001 0}       & {\it reserved} \\
      0010 0  & {\tt i[2] -> i[1]}               & {\tt zip2.b, unzip2.b} \\
\sout{0010 1} & {\it equivalent to 0010 0}       & {\it reserved} \\
      0011 0  & {\tt i[2] -> i[0]}               & {\tt zip.b} \\
      0011 1  & {\tt i[2] <- i[0]}               & {\tt unzip.b} \\

\hline

      0100 0  & {\tt i[3] -> i[2]}               & {\tt zip4.h, unzip4.h} \\
\sout{0100 1} & {\it equivalent to 0100 0}       & {\it reserved} \\
\sout{0101 0} & {\tt i[3] -> i[2], i[1] -> i[0]} & {\it reserved} \\
\sout{0101 1} & {\it equivalent to 0101 0}       & {\it reserved} \\
      0110 0  & {\tt i[3] -> i[1]}               & {\tt zip2.h} \\
      0110 1  & {\tt i[3] <- i[1]}               & {\tt unzip2.h} \\
      0111 0  & {\tt i[3] -> i[0]}               & {\tt zip.h} \\
      0111 1  & {\tt i[3] <- i[0]}               & {\tt unzip.h} \\

\hline

      1000 0  & {\tt i[4] -> i[3]}               & {\tt zip8, unzip8} \\
\sout{1000 1} & {\it equivalent to 1000 0}       & {\it reserved} \\
\sout{1001 0} & {\tt i[4] -> i[3], i[1] -> i[0]} & {\it reserved} \\
\sout{1001 1} & {\it equivalent to 1001 0}       & {\it reserved} \\
\sout{1010 0} & {\tt i[4] -> i[3], i[2] -> i[1]} & {\it reserved} \\
\sout{1010 1} & {\it equivalent to 1010 0}       & {\it reserved} \\
\sout{1011 0} & {\tt i[4] -> i[3], i[2] -> i[0]} & {\it reserved} \\
\sout{1011 1} & {\tt i[4] <- i[3], i[2] <- i[0]} & {\it reserved} \\

\hline

      1100 0  & {\tt i[4] -> i[2]}               & {\tt zip4} \\
      1100 1  & {\tt i[4] <- i[2]}               & {\tt unzip4} \\
\sout{1101 0} & {\tt i[4] -> i[2], i[1] -> i[0]} & {\it reserved} \\
\sout{1101 1} & {\tt i[4] <- i[2], i[1] <- i[0]} & {\it reserved} \\
      1110 0  & {\tt i[4] -> i[1]}               & {\tt zip2} \\
      1110 1  & {\tt i[4] <- i[1]}               & {\tt unzip2} \\
      1111 0  & {\tt i[4] -> i[0]}               & {\tt zip} \\
      1111 1  & {\tt i[4] <- i[0]}               & {\tt unzip} \\
\end{tabular}
\end{center}
\end{small}
\caption{RV32 modes for {\tt gzip} instruction}
\label{gzip-modes}
\end{table}

\begin{figure}[t]
\begin{center}
\input{bextcref-printperm-gzip-noflip}
\end{center}
\caption{\texttt{gzip} permutation network without ``flip'' stages}
\label{permnet-gzip-noflip}
\end{figure}

Like GREV and rotate shift, the {\tt gzip} instruction can be implemented using a short
sequence of atomic permutations, that are enabled or disabled by the mode (shamt)
bits. But zip has one stage fewer than GREV and the LSB bit of mode controls the order
in which the stages are applied:

\input{bextcref-gzip32}

Alternatively {\tt gzip} can be implemented in a single network with one more
stage than GREV, with the additional first and last stage executing a
permutation that effectively reverses the order of the inner stages. However,
since the inner stages only mux half of the bits in the word each, a hardware
implementation using this additional ``flip'' stages might actually be more
expensive than simply creating two networks.

\input{bextcref-gzip32-alt}

Figure~\ref{permnet-gzip-flip} shows the {\tt gzip} permutation network with
``flip'' stages and Figure~\ref{permnet-gzip-noflip} shows the {\tt gzip}
permutation network without ``flip'' stages.

\begin{figure}[t]
\begin{center}
\input{bextcref-printperm-gzip-flip}
\end{center}
\caption{\texttt{gzip} permutation network with ``flip'' stages}
\label{permnet-gzip-flip}
\end{figure}

\input{bextgzip}

There is no R-type instruction for {\tt gzip}. It is an I-type only instruction.
\texttt{gzip} can use the instruction encoding for ``rotate left immediate''.
