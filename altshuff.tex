\chapter{Alternative to \texttt{shuffle} instruction}

There are a couple of issues with the {\tt shuffle} instruction as currently proposed.

(1) It performs a fairly complex operation (the description of the instruction
spans 4 pages).

(2) It tries to do two things at the same time, namely perform various zip/unzip
operations and perform butterfly operations of different orders.

(3) Even though all butterfly stages should be present in a GREV unit, tapping into
those stages to inject the masks for {\tt shuffle} increases overall complexity of
the core.

(4) Implementing a butterfly+mask operation can easily be done with grevi, zip,
and the mix pattern (and+andc+or).

This chapter proposes to replace the {\tt shuffle} instruction with a generalized
{\tt zip} instruction with an encoding similar to {\tt grevi}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Generalized zip/unzip (\texttt{gzip})}
\label{gzip}

{\it Under construction}

{\tt gzip} is the third bit permutation instruction in XBitmanip, after {\tt rori}
and {\tt grevi}.

The {\tt gzip} instruction uses an I-type encoding similar to {\tt grevi}. There
are XLEN different generalized zip operations, some of which are reserved because
they are no-ops or equivalent to other modes. See Table~\ref{gzip-modes}. The
reserved modes can be used to encode unary functions such as {\tt ctz} and {\tt clz}.

\begin{table}[h]
\begin{small}
\begin{center}
\begin{tabular}{c l l}
      mode   & Bit index rotations               & Instruction \\ \hline

\sout{0000 0} & no-op                            & {\it reserved} \\
\sout{0000 1} & no-op                            & {\it reserved} \\
      0001 0  & {\tt i[1] -> i[0]}               & {\tt zip.n, unzip.n} \\
\sout{0001 1} & {\it equivalent to 0001 0}       & {\it reserved} \\
      0010 0  & {\tt i[2] -> i[1]}               & {\tt zip2.b, unzip2.b} \\
\sout{0010 1} & {\it equivalent to 0010 0}       & {\it reserved} \\
      0011 0  & {\tt i[2] -> i[0]}               & {\tt zip.b} \\
      0011 1  & {\tt i[2] <- i[0]}               & {\tt unzip.b} \\

\hline

      0100 0  & {\tt i[3] -> i[2]}               & {\tt zip4.h, unzip4.h} \\
\sout{0100 1} & {\it equivalent to 0100 0}       & {\it reserved} \\
      0101 0  & {\tt i[3] -> i[2], i[1] -> i[0]} & --- \\
\sout{0101 1} & {\it equivalent to 0101 0}       & {\it reserved} \\
      0110 0  & {\tt i[3] -> i[1]}               & {\tt zip2.h} \\
      0110 1  & {\tt i[3] <- i[1]}               & {\tt unzip2.h} \\
      0111 0  & {\tt i[3] -> i[0]}               & {\tt zip.h} \\
      0111 1  & {\tt i[3] <- i[0]}               & {\tt unzip.h} \\

\hline

      1000 0  & {\tt i[4] -> i[3]}               & {\tt zip8, unzip8} \\
\sout{1000 1} & {\it equivalent to 1000 0}       & {\it reserved} \\
      1001 0  & {\tt i[4] -> i[3], i[1] -> i[0]} & --- \\
\sout{1001 1} & {\it equivalent to 1001 0}       & {\it reserved} \\
      1010 0  & {\tt i[4] -> i[3], i[2] -> i[1]} & --- \\
\sout{1010 1} & {\it equivalent to 1010 0}       & {\it reserved} \\
      1011 0  & {\tt i[4] -> i[3], i[2] -> i[0]} & --- \\
      1011 1  & {\tt i[4] <- i[3], i[2] <- i[0]} & --- \\

\hline

      1100 0  & {\tt i[4] -> i[2]}               & {\tt zip4} \\
      1100 1  & {\tt i[4] <- i[2]}               & {\tt unzip4} \\
      1101 0  & {\tt i[4] -> i[2], i[1] -> i[0]} & --- \\
      1101 1  & {\tt i[4] <- i[2], i[1] <- i[0]} & --- \\
      1110 0  & {\tt i[4] -> i[1]}               & {\tt zip2} \\
      1110 1  & {\tt i[4] <- i[1]}               & {\tt unzip2} \\
      1111 0  & {\tt i[4] -> i[0]}               & {\tt zip} \\
      1111 1  & {\tt i[4] <- i[0]}               & {\tt unzip} \\
\end{tabular}
\end{center}
\end{small}
\caption{RV32 modes for {\tt gzip} instruction}
\label{gzip-modes}
\end{table}

Like GREV and rotate shift, the {\tt gzip} instruction can be implemented using a short
sequence of atomic permutations, that are enabled or disabled by the mode (shamt)
bits. But zip has one stage fewer than GREV and the LSB bit of mode controls the order
in which the stages are applied:

\input{bextcref-gzip32}

Alternatively {\tt gzip} can be implemented in a single network with one more
stage than GREV, with the additional first and last stage executing a
permutation that effectively reverses the order of the inner stages. However,
since the inner stages only mux half of the bits in the word each, a hardware
implementation using this additional ``flip'' stages might actually be more
expensive than simply creating two networks.

\input{bextcref-gzip32-alt}

There is no R-type instruction for {\tt gzip}. It is an I-type only instruction.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Visualizations of permutation operators}

\input{bextcref-printperm}
