\chapter{RISC-V Bitmanip Extension}
\label{bext}

In the proposals provided in this chapter, the C code examples are for
illustration purposes only. They are not optimal implementations, but are
intended to specify the desired functionality. See Section~\ref{fastc} for fast
C code for use in emulators.

The section on opcode encodings are mere placeholders.

The final standard will likely define a range of Z-extensions for different bit
manipulation instructions, with the ``B'' extension itself being a mix of
instructions from those Z-extensions. It is completely unclear as of yet what
this will look like, but an educated guess could look like this:

\begin{center}
\begin{tikzpicture}
 \node (clz) { \texttt{clz, ctz} };
 \node (pcnt) [below=0.5cm of clz.west,anchor=west] { \texttt{pcnt, andc} };
 \node (cnot) [right=4.0cm of pcnt.west,anchor=west] { \texttt{c.not} };
 \node (slo) [below=0.5cm of pcnt.west,anchor=west] { \texttt{slo[i], sro[i]} };
 \node (min) [below=0.5cm of slo.west,anchor=west] { \texttt{min[u], max[u]} };

 \node (rol) [below=1.0cm of min.west,anchor=west] { \texttt{rol, ror[i]} };
 \node (bswap) [below=0.5cm of rol.west,anchor=west] { \texttt{bswap, brev} };
 \node (brevp) [right=4.0cm of bswap.west,anchor=west] { \texttt{brev.p} };
 \node (grev) [right=6.5cm of bswap.west,anchor=west] { \texttt{grev[i]} };

 \node (zip) [below=1.0cm of bswap.west,anchor=west] { \texttt{zip, unzip, zip.n} };
 \node (shuffle) [right=6.5cm of zip.west,anchor=west] { \texttt{shfl[i], unshfl[i]} };

 \node (bext) [below=1.0cm of zip.west,anchor=west] { \texttt{bext, bdep} };

 \node (clmul) [below=1.0cm of bext.west,anchor=west] { \texttt{clmul[h]} };

 \node (cmov) [right=3.5cm of bext.west,anchor=north west] { \texttt{cmov, cmix} };
 \node (fsl) [below=0.5cm of cmov.west,anchor=west] { \texttt{fsl, fsr} };

 \node (crc32) [below=1.0cm of clmul.west,anchor=west] { \texttt{crc32.[bhwd]} };
 \node (crc32c) [below=0.5cm of crc32.west,anchor=west] { \texttt{crc32c.[bhwd]} };

 \node (bmatxor) [right=3.5cm of crc32.west,anchor=west] { \texttt{bmat[x]or} };
 \node (bmatflip) [below=0.5cm of bmatxor.west,anchor=west] { \texttt{bmatflip} };

 \begin{scope}[on background layer]
   \node (B) at ($ (clz.north west) + (0,+0.2cm) $) [above right, text=gray] { \textbf{B} };
   \draw [draw=black, fill=gray, opacity=0.2] ($ (clz.north west) + (0,+0.2cm) $) rectangle ($ (clmul.south west) + (6.0cm,-0.2cm) $);

   \node (bmini) at ($ (clz.west) + (-0.5cm,0) $) [left, text=red] { \textbf{Zbmini} };
   \draw [draw=black, fill=red, opacity=0.2] ($ (clz.north west) + (-0.5cm,0) $) rectangle ($ (bswap.south west) + (3.5cm,0) $);

   \node (bperm) at ($ (rol.north west) + (+6.5cm,0) $) [above right, text=blue] { \textbf{Zbperm} };
   \draw [draw=black, fill=blue, opacity=0.2] ($ (rol.north west) + (-0.2cm,0) $) rectangle ($ (shuffle.south east) + (0,0) $);

   \node (bextdep) at ($ (bext.west) + (-0.5cm,0) $) [left, text=red] { \textbf{Zbextdep} };
   \draw [draw=black, fill=red, opacity=0.2] ($ (bext.north west) + (-0.5cm,0) $) rectangle ($ (bext.south west) + (3.0cm,0) $);

   \node (betrnary) at ($ (cmov.west) + (3.0cm,0) $) [right, text=blue] { \textbf{Zbternary} };
   \draw [draw=black, fill=blue, opacity=0.2] ($ (cmov.north west) + (-0.2cm,0) $) rectangle ($ (fsl.south west) + (3.0cm,0) $);

   \node (bclmul) at ($ (clmul.west) + (-0.5cm,0) $) [left, text=red] { \textbf{Zbclmul} };
   \draw [draw=black, fill=red, opacity=0.2] ($ (clmul.north west) + (-0.5cm,0) $) rectangle ($ (clmul.south west) + (3.0cm,0) $);

   \node (bcrc) at ($ (crc32.west) + (-0.5cm,0) $) [left, text=blue] { \textbf{Zbcrc} };
   \draw [draw=black, fill=blue, opacity=0.2] ($ (crc32.north west) + (-0.5cm,0) $) rectangle ($ (crc32c.south west) + (3.0cm,0) $);

   \node (bmat) at ($ (bmatxor.west) + (3.0cm,0) $) [right, text=red] { \textbf{Zbmat} };
   \draw [draw=black, fill=red, opacity=0.2] ($ (bmatxor.north west) + (-0.2cm,0) $) rectangle ($ (bmatflip.south west) + (3.0cm,0) $);
 \end{scope}
\end{tikzpicture}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Basic bit manipulation instructions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Count Leading/Trailing Zeros (\texttt{clz, ctz})}

\begin{rvb}
  RV32, RV64:
    clz rd, rs
    ctz rd, rs

  RV64 only:
    clzw rd, rs
    ctzw rd, rs
\end{rvb}

The {\tt clz} operation counts the number of 0 bits at the MSB end of the
argument.  That is, the number of 0 bits before the first 1 bit counting from
the most significant bit. If the input is 0, the output is XLEN. If the input
is -1, the output is 0.

The {\tt ctz} operation counts the number of 0 bits at the LSB end of the
argument. If the input is 0, the output is XLEN. If the input is -1, the
output is 0.

\input{bextcref-clz-ctz}

% \subsection{References}
%
% https://en.wikipedia.org/wiki/Find\_first\_set\#CLZ
%
% https://fgiesen.wordpress.com/2013/10/18/bit-scanning-equivalencies/

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Count Bits Set (\texttt{pcnt})}

\begin{rvb}
  RV32, RV64:
    pcnt rd, rs

  RV64 only:
    pcntw rd, rs
\end{rvb}

This instruction counts the number of 1 bits in a register. This operations is known as
population count, popcount, sideways sum, bit summation, or Hamming weight.~\cite{HammingWeight,Warren12}

\input{bextcref-pcnt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{And-with-complement (\texttt{andc})}

\begin{rvb}
  RV32, RV64:
    andc rd, rs1, rs2
\end{rvb}

This instruction implements the and-with-complement operation.

\input{bextcref-andc}

Other with-complement operations ({\tt orc, nand, nor}, etc) can be implemented
by combining {\tt not} ({\tt c.not}) with the base ALU operation. (Which can
fit in 32 bit when using two compressed instructions.) Only and-with-complement
occurs frequently enough to warrant a dedicated instruction.

% \subsection{Justification}
%
% http://svn.clifford.at/handicraft/2017/bitcode/
%
% \subsection{References}
%
% http://www.hackersdelight.org/basics2.pdf

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Min/max instructions (\texttt{min, max, minu, maxu})}

\begin{rvb}
  RV32, RV64:
    min rd, rs1, rs2
    max rd, rs1, rs2
    minu rd, rs1, rs2
    maxu rd, rs1, rs2

  RV64 only:
    minw rd, rs1, rs2
    maxw rd, rs1, rs2
    minuw rd, rs1, rs2
    maxuw rd, rs1, rs2
\end{rvb}

We define 4 R-type instructions \texttt{min, max, minu, maxu} with the
following semantics:

\input{bextcref-minmax}

Code that performs saturated arithmetic on a word size $<$ \texttt{XLEN} needs to perform
min/max operations frequently. A simple way of performing those operations without branching
can benefit those programs.

SAT solvers spend a lot of time calculating the absolute value of a signed
integer due to the way CNF literals are commonly encoded~\cite{BiereComm}. With
\texttt{max} (or \texttt{minu}) this is a two-instruction operation:

\begin{minipage}{\linewidth}
\begin{verbatim}
  neg a1, a0
  max a0, a0, a1
\end{verbatim}
\end{minipage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Shift Ones (Left/Right) (\texttt{slo,\ sloi,\ sro,\ sroi})}

\begin{rvb}
  RV32, RV64:
    slo rd, rs1, rs2
    sro rd, rs1, rs2
    sloi rd, rs1, imm
    sroi rd, rs1, imm

  RV64 only:
    slow rd, rs1, rs2
    srow rd, rs1, rs2
    sloiw rd, rs1, imm
    sroiw rd, rs1, imm
\end{rvb}

These instructions are similar to shift-logical operations from the base
spec, except instead of shifting in zeros, they shift in ones.

\input{bextcref-sxo}

\texttt{s(l/r)o(i)} is encoded similarly to the logical shifts in the
base spec. However, the spec of the entire family of instructions is
changed so that the high bit of the instruction indicates the value to
be inserted during a shift. This means that a \texttt{sloi} instruction
can be encoded similarly to an \texttt{slli} instruction, but with a 1
in the highest bit of the encoded instruction. This encoding is
backwards compatible with the definition for the shifts in the base
spec, but allows for simple addition of a ones-insert.

When implementing this circuit, the only change in the ALU over a
standard logical shift is that the value shifted in is not zero, but is
a 1-bit register value that has been forwarded from the high bit of the
instruction decode. This creates the desired behavior on both logical
zero-shifts and logical ones-shifts.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Bit permutation instructions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Rotate (Left/Right) (\texttt{rol,\ ror,\ rori})}

\begin{rvb}
  RV32, RV64:
    ror rd, rs1, rs2
    rol rd, rs1, rs2
    rori rd, rs1, imm

  RV64 only:
    rorw rd, rs1, rs2
    rolw rd, rs1, rs2
    roriw rd, rs1, imm
\end{rvb}

These instructions are similar to shift-logical operations from the base
spec, except they shift in the values from the opposite side of the
register, in order. This is also called `circular shift'.

\input{bextcref-rox}

Rotate shift is implemented very similarly to the other shift
instructions. One possible way to encode it is to re-use the way that
bit 30 in the instruction encoding selects `arithmetic shift' when bit
31 is zero (signalling a logical-zero shift). We can re-use this so that
when bit 31 is set (signalling a logical-ones shift), if bit 30 is also
set, then we are doing a rotate. The following table summarizes the
behavior. The generalized reverse instructions can be encoded using the
bit pattern that would otherwise encode an ``Arithmetic Left Shift''
(which is an operation that does not exist). Likewise, the generalized zip
instruction can be encoded using the bit pattern that would otherwise
encode an ``Rotate left immediate''.

\begin{center}
\begin{tabular}{lll}
Bit 31 & Bit 30 & Meaning \\
\hline
0 & 0 & Logical Shift-Zeros \\
0 & 1 & Arithmetic Shift \\
1 & 0 & Logical Shift-Ones \\
1 & 1 & Rotate \\
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[t]
\begin{center}
\input{bextcref-printperm-ror}
\end{center}
\caption{\texttt{ror} permutation network}
\label{permnet-ror}
\end{figure}

\subsection{Generalized Reverse (\texttt{grev,\ grevi})}
\label{grev}

\begin{rvb}
  RV32, RV64:
    grev rd, rs1, rs2
    grevi rd, rs1, imm
\end{rvb}

This instruction provides a single hardware instruction that can implement all
of byte-order swap, bitwise reversal, short-order-swap, word-order-swap
(RV64), nibble-order swap, bitwise reversal in a byte, etc, all from a single
hardware instruction. It takes in a single register value and an immediate that
controls which function occurs, through controlling the levels in the recursive
tree at which reversals occur.

This operation iteratively checks each bit $i$ in rs2 from $i=0$ to
$\textrm{XLEN}-1$, and if the corresponding bit is set, swaps each adjacent
pair of $2^i$ bits.

\begin{figure}[t]
\begin{center}
\input{bextcref-printperm-grev}
\end{center}
\caption{\texttt{grev} permutation network}
\label{permnet-grev}
\end{figure}

\input{bextcref-grev}

The above pattern should be intuitive to understand in order to extend
this definition in an obvious manner for RV128.

\begin{table}[h]
\begin{small}
\begin{center}
\begin{tabular}{r l p{0.5in} r l p{0.3in} r l}

\multicolumn{2}{c}{RV32} & &
\multicolumn{5}{c}{RV64} \\

\cline{1-2}
\cline{4-8}

\multicolumn{1}{c}{shamt} & Instruction & &
\multicolumn{1}{c}{shamt} & Instruction & &
\multicolumn{1}{c}{shamt} & Instruction \\

\cline{1-2}
\cline{4-5}
\cline{7-8}

 0: 00000 & ---           &   &  0: 000000 & ---           &   & 32: 100000 & {\tt wswap} \\
 1: 00001 & {\tt brev.p}  &   &  1: 000001 & {\tt brev.p}  &   & 33: 100001 & ---         \\
 2: 00010 & {\tt pswap.n} &   &  2: 000010 & {\tt pswap.n} &   & 34: 100010 & ---         \\
 3: 00011 & {\tt brev.n}  &   &  3: 000011 & {\tt brev.n}  &   & 35: 100011 & ---         \\
 4: 00100 & {\tt nswap.b} &   &  4: 000100 & {\tt nswap.b} &   & 36: 100100 & ---         \\
 5: 00101 & ---           &   &  5: 000101 & ---           &   & 37: 100101 & ---         \\
 6: 00110 & {\tt pswap.b} &   &  6: 000110 & {\tt pswap.b} &   & 38: 100110 & ---         \\
 7: 00111 & {\tt brev.b}  &   &  7: 000111 & {\tt brev.b}  &   & 39: 100111 & ---         \\

\cline{1-2}
\cline{4-5}
\cline{7-8}

 8: 01000 & {\tt bswap.h} &   &  8: 001000 & {\tt bswap.h} &   & 40: 101000 & ---         \\
 9: 01001 & ---           &   &  9: 001001 & ---           &   & 41: 101001 & ---         \\
10: 01010 & ---           &   & 10: 001010 & ---           &   & 42: 101010 & ---         \\
11: 01011 & ---           &   & 11: 001011 & ---           &   & 43: 101011 & ---         \\
12: 01100 & {\tt nswap.h} &   & 12: 001100 & {\tt nswap.h} &   & 44: 101100 & ---         \\
13: 01101 & ---           &   & 13: 001101 & ---           &   & 45: 101101 & ---         \\
14: 01110 & {\tt pswap.h} &   & 14: 001110 & {\tt pswap.h} &   & 46: 101110 & ---         \\
15: 01111 & {\tt brev.h}  &   & 15: 001111 & {\tt brev.h}  &   & 47: 101111 & ---         \\

\cline{1-2}
\cline{4-5}
\cline{7-8}

16: 10000 & {\tt hswap}   &   & 16: 010000 & {\tt hswap.w} &   & 48: 110000 & {\tt hswap} \\
17: 10001 & ---           &   & 17: 010001 & ---           &   & 49: 110001 & ---         \\
18: 10010 & ---           &   & 18: 010010 & ---           &   & 50: 110010 & ---         \\
19: 10011 & ---           &   & 19: 010011 & ---           &   & 51: 110011 & ---         \\
20: 10100 & ---           &   & 20: 010100 & ---           &   & 52: 110100 & ---         \\
21: 10101 & ---           &   & 21: 010101 & ---           &   & 53: 110101 & ---         \\
22: 10110 & ---           &   & 22: 010110 & ---           &   & 54: 110110 & ---         \\
23: 10111 & ---           &   & 23: 010111 & ---           &   & 55: 110111 & ---         \\

\cline{1-2}
\cline{4-5}
\cline{7-8}

24: 11000 & {\tt bswap}   &   & 24: 011000 & {\tt bswap.w} &   & 56: 111000 & {\tt bswap} \\
25: 11001 & ---           &   & 25: 011001 & ---           &   & 57: 111001 & ---         \\
26: 11010 & ---           &   & 26: 011010 & ---           &   & 58: 111010 & ---         \\
27: 11011 & ---           &   & 27: 011011 & ---           &   & 59: 111011 & ---         \\
28: 11100 & {\tt nswap}   &   & 28: 011100 & {\tt nswap.w} &   & 60: 111100 & {\tt nswap} \\
29: 11101 & ---           &   & 29: 011101 & ---           &   & 61: 111101 & ---         \\
30: 11110 & {\tt pswap}   &   & 30: 011110 & {\tt pswap.w} &   & 62: 111110 & {\tt pswap} \\
31: 11111 & {\tt brev}    &   & 31: 011111 & {\tt brev.w}  &   & 63: 111111 & {\tt brev}  \\
\end{tabular}
\end{center}
\end{small}
\caption{Pseudo-instructions for {\tt grevi} instruction}
\label{grevi-modes}
\end{table}

The {\tt grev} operation can easily be implemented using a permutation
network with $log_2(\textrm{XLEN})$ stages. Figure~\ref{permnet-ror}
shows the permutation network for {\tt ror} for reference.
Figure~\ref{permnet-grev} shows the permutation network for {\tt grev}.

\texttt{grev} is encoded as standard R-type opcode and \texttt{grevi} is
encoded as standard I-type opcode. \texttt{grev} and \texttt{grevi} can
use the instruction encoding for ``arithmetic shift left''.

% \subsection{References}
%
% Hackers Delight, Chapter 7.1, ``Generalized Bit Reversal'' in
%
% https://books.google.com/books?id=iBNKMspIlqEC\&lpg=PP1\&pg=RA1-SL20-PA2\#v=onepage\&q\&f=false
%
% http://hackersdelight.org/

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Generalized Shuffle (\texttt{shfl}, \texttt{unshfl}, \texttt{shfli}, \texttt{unshfli})}
\label{gzip}

\begin{rvb}
  RV32, RV64:
    shfl rd, rs1, rs2
    unshfl rd, rs1, rs2
    shfli rd, rs1, imm
    unshfli rd, rs1, imm
\end{rvb}

Shuffle is the third bit permutation instruction in the RISC-V Bitmanip
extension, after rotary shift and generalized reverse. It implements a
generalization of the operation commonly known as perfect outer shuffle and its
inverse (shuffle/unshuffle), also known as zip/unzip or interlace/uninterlace.

Bit permutations can be understood as reversible functions on bit indices (i.e.
5 bit functions on RV32 and 6 bit functions on RV64).

\begin{center}
\begin{tabular}{l l}
Operation & Corresponding function on bit indices \\
\hline
Rotate shift & Addition modulo {\rm XLEN} \\
Generalized reverse & XOR with bitmask \\
Generalized shuffle & Bitpermutation \\
\end{tabular}
\end{center}

A generalized (un)shuffle operation has $log_2(\textrm{XLEN})-1$ control bits,
one for each pair of neighbouring bits in a bit index. When the bit is set,
generalized shuffle will swap the two index bits. The {\tt shfl} operation
performs this swaps in MSB-to-LSB order (performing a rotate left shift on
continuous regions of set control bits), and the {\tt unshfl} operation performs
the swaps in LSB-to-MSB order (performing a rotate right shift on continuous
regions of set control bits). Combining up to $log_2(\textrm{XLEN})$ of those
{\tt shfl}/{\tt unshfl} operations can implement any bitpermutation on the
bit indices.

The most common type of shuffle/unshuffle operation is one on an immediate
control value that only contains one continuous region of set bits. We call
those operations zip/unzip and provide pseudo-instructions for them.

Shuffle/unshuffle operations that only have individual bits set (not a continuous
region of two or more bits) are their own inverse. This means that a few of the
{\tt unshfli} opcodes are redundant with {\tt shfli} opcodes and therefore can
be reserved for encoding unary functions such as {\tt ctz}, {\tt clz}, and {\tt pcnt}.

\begin{table}[h]
\begin{small}
\begin{center}
\begin{tabular}{r c l l}
\multicolumn{1}{c}{shamt} &
\multicolumn{1}{c}{inv} &
Bit index rotations &
Pseudo-Instruction \\

\hline

 0: 0000 & 0 & no-op                            & ---                    \\
    0000 & 1 & no-op                            & {\it reserved}         \\
 1: 0001 & 0 & {\tt i[1] -> i[0]}               & {\tt zip.n, unzip.n}   \\
    0001 & 1 & {\it equivalent to 0001 0}       & {\it reserved}         \\
 2: 0010 & 0 & {\tt i[2] -> i[1]}               & {\tt zip2.b, unzip2.b} \\
    0010 & 1 & {\it equivalent to 0010 0}       & {\it reserved}         \\
 3: 0011 & 0 & {\tt i[2] -> i[0]}               & {\tt zip.b}            \\
    0011 & 1 & {\tt i[2] <- i[0]}               & {\tt unzip.b}          \\

\hline

 4: 0100 & 0 & {\tt i[3] -> i[2]}               & {\tt zip4.h, unzip4.h} \\
    0100 & 1 & {\it equivalent to 0100 0}       & {\it reserved}         \\
 5: 0101 & 0 & {\tt i[3] -> i[2], i[1] -> i[0]} & ---                    \\
    0101 & 1 & {\it equivalent to 0101 0}       & {\it reserved}         \\
 6: 0110 & 0 & {\tt i[3] -> i[1]}               & {\tt zip2.h}           \\
    0110 & 1 & {\tt i[3] <- i[1]}               & {\tt unzip2.h}         \\
 7: 0111 & 0 & {\tt i[3] -> i[0]}               & {\tt zip.h}            \\
    0111 & 1 & {\tt i[3] <- i[0]}               & {\tt unzip.h}          \\

\hline

 8: 1000 & 0 & {\tt i[4] -> i[3]}               & {\tt zip8, unzip8}     \\
    1000 & 1 & {\it equivalent to 1000 0}       & {\it reserved}         \\
 9: 1001 & 0 & {\tt i[4] -> i[3], i[1] -> i[0]} & ---                    \\
    1001 & 1 & {\it equivalent to 1001 0}       & {\it reserved}         \\
10: 1010 & 0 & {\tt i[4] -> i[3], i[2] -> i[1]} & ---                    \\
    1010 & 1 & {\it equivalent to 1010 0}       & {\it reserved}         \\
11: 1011 & 0 & {\tt i[4] -> i[3], i[2] -> i[0]} & ---                    \\
    1011 & 1 & {\tt i[4] <- i[3], i[2] <- i[0]} & ---                    \\

\hline

12: 1100 & 0 & {\tt i[4] -> i[2]}               & {\tt zip4}             \\
    1100 & 1 & {\tt i[4] <- i[2]}               & {\tt unzip4}           \\
13: 1101 & 0 & {\tt i[4] -> i[2], i[1] -> i[0]} & ---                    \\
    1101 & 1 & {\tt i[4] <- i[2], i[1] <- i[0]} & ---                    \\
14: 1110 & 0 & {\tt i[4] -> i[1]}               & {\tt zip2}             \\
    1110 & 1 & {\tt i[4] <- i[1]}               & {\tt unzip2}           \\
15: 1111 & 0 & {\tt i[4] -> i[0]}               & {\tt zip}              \\
    1111 & 1 & {\tt i[4] <- i[0]}               & {\tt unzip}            \\

\end{tabular}
\end{center}
\end{small}
\caption{RV32 modes and pseudo-instructions for {\tt shfli}/{\tt unshfli} instruction}
\label{gzip32-modes}
\end{table}

\begin{table}[h]
\begin{small}
\begin{center}
\begin{tabular}{r c l p{1in} r c l}
\multicolumn{1}{c}{shamt} &
\multicolumn{1}{c}{inv} &
Pseudo-Instruction & &
\multicolumn{1}{c}{shamt} &
\multicolumn{1}{c}{inv} &
Pseudo-Instruction \\

\cline{1-3}
\cline{5-7}

 0: 00000 & 0 & ---                      &   &   16: 10000 & 0 & {\tt zip16, unzip16}    \\
    00000 & 1 & {\it reserved}           &   &       10000 & 1 & {\it reserved}          \\
 1: 00001 & 0 & {\tt zip.n, unzip.n}     &   &   17: 10001 & 0 & ---                     \\
    00001 & 1 & {\it reserved}           &   &       10001 & 1 & {\it reserved}          \\
 2: 00010 & 0 & {\tt zip2.b, unzip2.b}   &   &   18: 10010 & 0 & ---                     \\
    00010 & 1 & {\it reserved}           &   &       10010 & 1 & {\it reserved}          \\
 3: 00011 & 0 & {\tt zip.b}              &   &   19: 10011 & 0 & ---                     \\
    00011 & 1 & {\tt unzip.b}            &   &       10011 & 1 & ---                     \\

\cline{1-3}
\cline{5-7}

 4: 00100 & 0 & {\tt zip4.h, unzip4.h}   &   &   20: 10100 & 0 & ---                     \\
    00100 & 1 & {\it reserved}           &   &       10100 & 1 & {\it reserved}          \\
 5: 00101 & 0 & ---                      &   &   21: 10101 & 0 & ---                     \\
    00101 & 1 & {\it reserved}           &   &       10101 & 1 & {\it reserved}          \\
 6: 00110 & 0 & {\tt zip2.h}             &   &   22: 10110 & 0 & ---                     \\
    00110 & 1 & {\tt unzip2.h}           &   &       10110 & 1 & ---                     \\
 7: 00111 & 0 & {\tt zip.h}              &   &   23: 10111 & 0 & ---                     \\
    00111 & 1 & {\tt unzip.h}            &   &       10111 & 1 & ---                     \\

\cline{1-3}
\cline{5-7}

 8: 01000 & 0 & {\tt zip8.w, unzip8.w}   &   &   24: 11000 & 0 & {\tt zip8}              \\
    01000 & 1 & {\it reserved}           &   &       11000 & 1 & {\tt unzip8}            \\
 9: 01001 & 0 & ---                      &   &   25: 11001 & 0 & ---                     \\
    01001 & 1 & {\it reserved}           &   &       11001 & 1 & ---                     \\
10: 01010 & 0 & ---                      &   &   26: 11010 & 0 & ---                     \\
    01010 & 1 & {\it reserved}           &   &       11010 & 1 & ---                     \\
11: 01011 & 0 & ---                      &   &   27: 11011 & 0 & ---                     \\
    01011 & 1 & ---                      &   &       11011 & 1 & ---                     \\

\cline{1-3}
\cline{5-7}

12: 01100 & 0 & {\tt zip4.w}             &   &   28: 11100 & 0 & {\tt zip4}              \\
    01100 & 1 & {\tt unzip4.w}           &   &       11100 & 1 & {\tt unzip4}            \\
13: 01101 & 0 & ---                      &   &   29: 11101 & 0 & ---                     \\
    01101 & 1 & ---                      &   &       11101 & 1 & ---                     \\
14: 01110 & 0 & {\tt zip2.w}             &   &   30: 11110 & 0 & {\tt zip2}              \\
    01110 & 1 & {\tt unzip2.w}           &   &       11110 & 1 & {\tt unzip2}            \\
15: 01111 & 0 & {\tt zip.w}              &   &   31: 11111 & 0 & {\tt zip}               \\
    01111 & 1 & {\tt unzip.w}            &   &       11111 & 1 & {\tt unzip}             \\

\end{tabular}
\end{center}
\end{small}
\caption{RV64 modes and pseudo-instructions for {\tt shfli}/{\tt unshfli} instruction}
\label{gzip64-modes}
\end{table}

\begin{figure}[t]
\begin{center}
\input{bextcref-printperm-gzip-noflip}
\end{center}
\caption{(un)shuffle permutation network without ``flip'' stages}
\label{permnet-gzip-noflip}
\end{figure}

Like GREV and rotate shift, the (un)shuffle instruction can be implemented using a short
sequence of elementary permutations, that are enabled or disabled by the shamt
bits. But (un)shuffle has one stage fewer than GREV. Thus shfli+unshfli together require
the same amount of encoding space as grevi.

\input{bextcref-gzip32}

Or for RV64:

\input{bextcref-gzip64}

The above pattern should be intuitive to understand in order to extend
this definition in an obvious manner for RV128.

Alternatively (un)shuffle) can be implemented in a single network with one more
stage than GREV, with the additional first and last stage executing a
permutation that effectively reverses the order of the inner stages. However,
since the inner stages only mux half of the bits in the word each, a hardware
implementation using this additional ``flip'' stages might actually be more
expensive than simply creating two networks.

\input{bextcref-gzip32-alt}

Figure~\ref{permnet-gzip-flip} shows the (un)shuffle permutation network with
``flip'' stages and Figure~\ref{permnet-gzip-noflip} shows the (un)shuffle
permutation network without ``flip'' stages.

\begin{figure}[t]
\begin{center}
\input{bextcref-printperm-gzip-flip}
\end{center}
\caption{(un)shuffle permutation network with ``flip'' stages}
\label{permnet-gzip-flip}
\end{figure}

The \texttt{zip} instruction with the upper half of its input cleared performs
the commonly needed ``fan-out'' operation. (Equivalent to {\tt bdep} with a
0x55555555 mask.) The \texttt{zip} instruction applied twice fans out the bits
in the lower quarter of the input word by a spacing of 4 bits.

For example, the following code calculates the bitwise prefix sum of the bits
in the lower byte of a 32 bit word on RV32:

\begin{minipage}{\linewidth}
\begin{verbatim}
  andi a0, a0, 0xff
  zip a0, a0
  zip a0, a0
  slli a1, a0, 4
  c.add a0, a1
  slli a1, a0, 8
  c.add a0, a1
  slli a1, a0, 16
  c.add a0, a1
\end{verbatim}
\end{minipage}

The final prefix sum is stored in the 8 nibbles of the {\tt a0} output word.

Similarly, the following code stores the indices of the set bits in the LSB
nibbles of the output word (with the LSB bit having index 1), with the unused
MSB nibbles in the output set to zero:

\begin{minipage}{\linewidth}
\begin{verbatim}
  andi a0, a0, 0xff
  zip a0, a0
  zip a0, a0
  slli a1, a0, 1
  or a0, a0, a1
  slli a1, a0, 2
  or a0, a0, a1
  li a1, 0x87654321
  and a1, a0, a1
  bext a0, a1, a0
\end{verbatim}
\end{minipage}

Other {\tt zip} modes can be used to ``fan-out'' in blocks of 2, 4, 8, or 16 bit.
{\tt zip} can be combined with {\tt grevi} to perform inner shuffles. For example
on RV64:

\begin{minipage}{\linewidth}
\begin{verbatim}
  li a0, 0x0000000012345678
  zip4 t0, a0    ; <- 0x0102030405060708
  nswap.b t1, t0 ; <- 0x1020304050607080
  zip8 t2, a0    ; <- 0x0012003400560078
  bswap.h t3, t2 ; <- 0x1200340056007800
  zip16 t4, a0   ; <- 0x0000123400005678
  hswap.w t5, t4 ; <- 0x1234000056780000
\end{verbatim}
\end{minipage}

Another application for the zip instruction is generating Morton
code~\cite[MortonCode].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Bit Extract/Deposit (\texttt{bext,\ bdep})}

\begin{rvb}
  RV32, RV64:
    bext rd, rs1, rs2
    bdep rd, rs1, rs2

  RV64 only:
    bextw rd, rs1, rs2
    bdepw rd, rs1, rs2
\end{rvb}

This instructions implement the generic bit extract and bit deposit functions.
This operation is also referred to as bit gather/scatter, bit pack/unpack,
parallel extract/deposit, compress/expand, or right\_compress/right\_expand.

\texttt{bext} collects LSB justified bits to rd from rs1 using extract mask in rs2.

\texttt{bdep} writes LSB justified bits from rs1 to rd using deposit mask in rs2.

\input{bextcref-bext}

Implementations may choose to use smaller multi-cycle implementations of
\texttt{bext} and \texttt{bdep}, or even emulate the instructions in software.

Even though multi-cycle \texttt{bext} and \texttt{bdep} often are not fast
enough to outperform algorithms that use sequences of shifts and bit masks,
dedicated instructions for those operations can still be of great advantage in
cases where the mask argument is not constant.

For example, the following code efficiently calculates the index of the tenth
set bit in {\tt a0} using \texttt{bdep}:

\begin{minipage}{\linewidth}
\begin{verbatim}
  li a1, 0x00000200
  bdep a0, a1, a0
  ctz a0, a0
\end{verbatim}
\end{minipage}

For cases with a constant mask an optimizing compiler would decide when to use
\texttt{bext} or \texttt{bdep} based on the optimization profile for the
concrete processor it is optimizing for. This is similar to the decision
whether to use MUL or DIV with a constant, or to perform the same operation
using a longer sequence of much simpler operations.

% \subsection{Justification}
%
% http://svn.clifford.at/handicraft/2017/permsyn/
%
% \subsection{References}
%
% http://programming.sirrida.de/bit\_perm.html\#gather\_scatter
%
% Hackers Delight, Chapter 7.1, ``Compress, Generalized Extract'' in
%
% https://books.google.com/books?id=iBNKMspIlqEC\&lpg=PP1\&pg=RA1-SL20-PA2\#v=onepage\&q\&f=false
%
% http://hackersdelight.org/
%
% https://github.com/cliffordwolf/bextdep
%
% http://palms.ee.princeton.edu/system/files/Hilewitz_JSPS_08.pdf

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Carry-less multiply (\texttt{clmul, clmulh})}

\begin{rvb}
  RV32, RV64:
    clmul rd, rs1, rs2
    clmulh rd, rs1, rs2

  RV64 only:
    clmulw rd, rs1, rs2
\end{rvb}

Calculate the carry-less product~\cite{CarryLessProduct} of the two arguments. \texttt{clmul}
produces the lower half of the carry-less product and \texttt{clmulh} produces the upper half
of the carry-less product.

We need to coordinate with the crypto extension work group if carry-less multiply should
be part of the B-extension or crypto-extension. (One possible option is to have a vectorized
clmul instruction in the crypto-extension and a scalar version in the B-extension.)

\input{bextcref-clmul}

The classic applications for \texttt{clmul} are the GCM and CRC~\cite{FastCRC,Wolf18A}, but more
applications exist, including the following examples.

There are obvious applications in hashing and pseudo random number generations. For
example, it has been reported that hashes based on carry-less multiplications can
outperform Google's CityHash~\cite{CLHASH}.

\texttt{clmul} of a number with itself inserts zeroes between each input bit. This can
be useful for generating Morton code~\cite{MortonCode}.

\texttt{clmul} of a number with -1 calculates the prefix XOR operation. This can
be useful for decoding gray codes.

Carry-less multiply can be used to implement Erasure code efficiently~\cite{ClmulErasureCode}.

SPARC introduced similar instructions (XMULX, XMULXHI) in SPARC T3 in 2010.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{CRC instructions (\texttt{crc32.[bhwd], crc32c.[bhwd]})}

\begin{rvb}
  RV32, RV64:
    crc32.b rd, rs
    crc32.h rd, rs
    crc32.w rd, rs
    crc32c.b rd, rs
    crc32c.h rd, rs
    crc32c.w rd, rs

  RV64 only:
    crc32.d rd, rs
    crc32c.d rd, rs
\end{rvb}

Unary CRC instructions that interpret the bits of rs1 as a CRC32/CRC32C state
and perform a polynomial reduction of that state shifted left by 8, 16, 32, or
64 bits.

The instructions return the new CRC32/CRC32C state.

The \texttt{crc32w}/\texttt{crc32cw} instructions are equivalent to executing
\texttt{crc32h}/\texttt{crc32ch} twice, and \texttt{crc32h}/\texttt{crc32ch}
instructions are equivalent to executing \texttt{crc32b}/\texttt{crc32cb}
twice.

All 8 CRC instructions operate on bit-reflected data.

\input{bextcref-crc}

Payload data must be XOR'ed into the LSB end of the state before executing the
CRC instruction. The following code demonstrates the use of \texttt{crc32.b}:

\begin{minipage}{\linewidth}
\begin{verbatim}
  uint32_t crc32_demo(const uint8_t *p, int len)
  {
    uint32_t x = 0xffffffff;
    for (int i = 0; i < len; i++) {
      x = x ^ p[i];
      x = crc32_b(x);
    }
    return ~x;
  }
\end{verbatim}
\end{minipage}

In terms of binary polynomial arithmetic those instructions perform the operation
$$ \texttt{rd}'(x) = (\texttt{rs1}'(x) \cdot x^N) \; \textrm{mod} \; \{\texttt{1}, P'\}(x)\textrm, $$
with $N \in \{8, 16, 32, 64\}$,
$P = \texttt{0xEDB8\_8320}$ for CRC32 and $P = \texttt{0x82F6\_3B78}$ for CRC32C,
$a'$ denoting the XLEN bit reversal of $a$,
and $\{a, b\}$ denoting bit concatenation.
Note that for example for CRC32 $\{\texttt{1}, P'\} = \texttt{0x1\_04C1\_1DB7}$
on RV32 and $\{\texttt{1}, P'\} = \texttt{0x1\_04C1\_1DB7\_0000\_0000}$ on RV64.

These dedicated CRC instructions are meant for RISC-V implementations without fast multiplier
and therefore without fast \texttt{clmul[h]}. For implementations with fast \texttt{clmul[h]}
it is recommended to use the methods described in~\cite{FastCRC} and demonstrated in~\cite{Wolf18A}
that can process XLEN input bits using just one carry-less multiply for arbitrary CRC polynomials.

In applications where those methods are not applicable it is possible to emulate the dedicated CRC
instructions using two carry-less multiplies that implement a Barrett reduction. The following example
implements a replacement for \texttt{crc32.w} (RV32).

\begin{minipage}{\linewidth}
\begin{verbatim}
crc32_w:
  li t0, 0x04C11DB7
  li t1, 0x04D101DF
  brev a0, a0
  clmulh a1, a0, t1
  xor a1, a1, a0
  clmul a0, a1, t0
  brev a0, a0
  ret
\end{verbatim}
\end{minipage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Bit-matrix operations (\texttt{bmatxor, bmator, bmatflip})}

\begin{rvb}
  RV64 only:
    bmator rd, rs1, rs2
    bmatxor rd, rs1, rs2
    bmatflip rd, rs
\end{rvb}

These are 64-bit-only instruction that are not available on RV32. On RV128 they
ignore the upper half of operands and set the upper half of the results to zero.

This instructions interpret a 64-bit value as 8x8 binary matrix.

\texttt{bmatxor} performs a matrix-matrix multiply with boolean AND as multiply
operator and boolean XOR as addition operator.

\texttt{bmator} performs a matrix-matrix multiply with boolean AND as multiply
operator and boolean OR as addition operator.

\texttt{bmatflip} is a unary operator that transposes the source matrix. It is
equivalent to \texttt{zip; zip; zip} on RV64.

Among other things, \texttt{bmatxor}/\texttt{bmator} can be used to perform
arbitrary permutations of bits within each byte (permutation matrix as 2nd
operand) or perform arbitrary permutations of bytes within a 64-bit word
(permutation matrix as 1st operand).

There are similar instructions in Cray XMT~\cite{CrayXMT}. The Cray X1
architecture even has a full 64x64 bit matrix multiply unit~\cite{CrayX1}.

The MMIX architecture has MOR and MXOR instructions with the same semantic.~\cite[p.~182f]{Knuth4A}

\input{bextcref-bmat}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Ternary bit-manipulation instructions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Conditional mix ({\tt cmix})}

\begin{rvb}
  RV32, RV64:
    cmix rd, rs1, rs2, rs2
\end{rvb}

The {\tt cmix rd, rs1, rs2, rs3} instruction selects bits from {\tt rs1} and {\tt rs3} based
on the bits in the control word {\tt rs2}. It is equivalent to the following sequence.

\begin{minipage}{\linewidth}
\begin{verbatim}
  and rd, rs1, rs2
  andc t0, rs3, rs2
  or rd, rd, t0
\end{verbatim}
\end{minipage}

Using {\tt cmix} a single butterfly or stage can be implemented in only two
instructions. Thus, arbitrary bit-permutations can be implemented using only
18 instruction (32 bit) or 22 instructions (64 bits).

\input{bextcref-cmix}

\subsection{Conditional move ({\tt cmov})}

\begin{rvb}
  RV32, RV64:
    cmov rd, rs1, rs2, rs2
\end{rvb}

The {\tt cmov rd, rs1, rs2, rs3} instruction selects {\tt rs1} if the control
word {\tt rs2} is non-zero, and {\tt rs3} if the control word is zero.

\input{bextcref-cmov}

\subsection{Funnel shift ({\tt fsl}, {\tt fsr})}

\begin{rvb}
  RV32, RV64:
    fsl rd, rs1, rs2, rs2
    fsr rd, rs1, rs2, rs2
\end{rvb}

The {\tt fsl rd, rs1, rs2, rs3} instruction creates a $2\cdot\textrm{XLEN}$ word
by concatenating rs1 and rs3 (with rs1 in the MSB half), rotate-left-shifts that
word by the amount indicated in the $log_2(\textrm{XLEN})+1$ LSB bits in rs2, and
then writes the MSB half of the result to rd.

The {\tt fsr rd, rs1, rs2, rs3} instruction creates a $2\cdot\textrm{XLEN}$ word
by concatenating rs1 and rs3 (with rs1 in the LSB half), rotate-right-shifts that
word by the amount indicated in the $log_2(\textrm{XLEN})+1$ LSB bits in rs2, and
then writes the LSB half of the result to rd.

\input{bextcref-fsl}

\input{bextcref-fsr}

A shift unit capable of either {\tt fsl} or {\tt fsr} is capable of performing all
the other shift functions, including the other funnel shift, with only minimal additional
logic.

For any values of {\tt A}, {\tt C}, and {\tt C}:

\begin{minipage}{\linewidth}
\begin{verbatim}
  fsl(A, B, C) = fsr(A, -B, C)
\end{verbatim}
\end{minipage}

And for any values {\tt x} and $0 \le \texttt{shamt} < \texttt{XLEN}$:

\begin{minipage}{\linewidth}
\begin{verbatim}
  sll(x, shamt) == fsl(x, shamt, 0)
  srl(x, shamt) == fsr(x, shamt, 0)
  sra(x, shamt) == fsr(x, shamt, sext_x)
  slo(x, shamt) == fsl(x, shamt, ~0)
  sro(x, shamt) == fsr(x, shamt, ~0)
  ror(x, shamt) == fsr(x, shamt, x)
  rol(x, shamt) == fsl(x, shamt, x)
\end{verbatim}
\end{minipage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Compressed NOT instructions (\texttt{c.not})}

The RISC-V ISA has no dedicated instructions for bitwise inverse (\texttt{not})
and arithmetic inverse (\texttt{neg}). Instead \texttt{not} is implemented as
\texttt{xori\ rd,\ rs,\ -1} and \texttt{neg} is implemented as \texttt{sub\ rd,\ x0,\ rs}.

In bitmanipulation code \texttt{not} is a very common operations. But there are
no compressed encodings for those operations because there is no
\texttt{c.xori} instruction.

Many bit manipulation operations that have dedicated opcodes in other ISAs
must be constructed from smaller atoms in RISC-V Bitmanip code. But
implementations might choose to implement them in a single micro-op using
macro-op-fusion. For this it can be helpful when the fused sequences are short.
\texttt{not} is a good candidate for macro-op-fusion, so it can be helpful to
have compressed opcodes for them.

The compressed instructions \texttt{c.not} must be supported by all
implementations that support the C extension and Bitmanip.

An encoding with the constraint \texttt{rd $=$ rs} would fit nicely in the reserved
space in \texttt{c.addi16sp/c.lui}.

\input{bextcompr-var1}

Without this constraint it would fit nicely in one of the two reserved ALU slots in
RVC Quadrant 1.

\input{bextcompr-var2}

A \texttt{c.not} instruction would be most useful as a prefix for macro-op fusion
if it supported \texttt{rd $\neq$ rs}. For postfix-fusion the constraint \texttt{rd $=$ rs}
is acceptable. Experiments will show which version has the best trade-off between
utility and used compressed encoding space.

The entire RVC encoding space is $15.585$~bits wide, the remaining reserved
encoding space in RVC is $11.155$~bits wide, not including space that is only reserved
on RV32/RV64. This means that above encodings would use $0.0065\%$ or $0.13\%$
of the RVC encoding space respectively, or $1.4\%$ or $2.8\%$ of the reserved
RVC encoding space respectively. Preliminary experiments have shown that NOT
instructions make up approximately $1\%$ of bitmanipulation code.~\cite{Wolf17A}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Micro architectural considerations and macro-op fusion for bit-manipulation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Fast {\tt MUL}, {\tt MULH}, {\tt MULHSU}, {\tt MULHU}}

A lot of bit manipulation code depends on ``multiply with magic number''-tricks. Often those
tricks need the upper half of the $2 \cdot \textrm{XLEN}$ product. Therefore decent performance
for the \texttt{MUL} and especially \texttt{MULH[[S]U]} instructions is important for fast
bit manipulation code.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Fused NOT instructions}

Preliminary experiments have shown that NOT instructions make up approximately
$1\%$ of bitmanipulation code size, more when looking at dynamic instruction count.~\cite{Wolf17A}

Therefore it makes sense to fuse NOT instructions with other ALU instructions, if possible.

The most important form of NOT fusion is postfix fusion:

\begin{minipage}{\linewidth}
\begin{verbatim}
  alu_op rd, rs1, rs2
  not rd, rd
\end{verbatim}
\end{minipage}

But there is also additional value in prefix fusion:

\begin{minipage}{\linewidth}
\begin{verbatim}
  not rd, rs1
  alu_op rd, rd, rs2

  not rd, rs2
  alu_op rd, rs1, rd
\end{verbatim}
\end{minipage}

The compressed NOT instructions {\tt c.not} helps keeping those fused sequences short.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Fused {\tt slli-srli} and {\tt slli-srai} sequences}

Pairs of left end right shifts are common operations for extracting a bit field.

To extract the continuous bit field starting at {\tt pos} with length {\tt len}
from {\tt rs} (with $\texttt{pos}>0$, $\texttt{len}>0$, and
$\texttt{pos}+\texttt{len}\le\textrm{XLEN}$):

\begin{minipage}{\linewidth}
\begin{verbatim}
  slli rd, rs, (XLEN-len-pos)
  srli rd, rd, (XLEN-len)
\end{verbatim}
\end{minipage}

Using \texttt{srai} instead of \texttt{srli} will sign-extend the extracted bit-field.

Similarly, placing a bit field with length {\tt len} at the position {\tt pos}:

\begin{minipage}{\linewidth}
\begin{verbatim}
  slli rd, rs, (XLEN-len)
  srli rd, rd, (XLEN-len-pos)
\end{verbatim}
\end{minipage}

If possible, an implementation should fuse this two shift operations into a single
macro-op.

Note that the 2nd shift instruction can use a compressed encoding, yielding a 48-bit fused instruction.

For mask generation the following 48-bit sequence can be used to create a mask with a continous
run of 1 bits of length {\tt len} at position {\tt pos}:

\begin{minipage}{\linewidth}
\begin{verbatim}
  c.li rd, -1
  c.slli rd, (XLEN-len)
  c.srli rd, (XLEN-len-pos)
\end{verbatim}
\end{minipage}

This can be a useful sequence on RV64, where loading an arbitrary 64-bit constant would usually
require at least 96 bits (using \texttt{c.ld}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Opcode Encodings}
\label{opcodes}

This chapter contains proposed encodings for most of the instructions described
in this document. {\bf DO NOT IMPLEMENT THESE OPCODES YET.} We are trying to get
official opcodes assigned and will update this chapter soon with the official
opcodes.

% Opcodes:
% 0010011 OP-IMM
% 0110011 OP
% 0011011 OP-IMM-32
% 0111011 OP-32

% Shift Opcodes:
%         | SLL  SRL  SRA | GREV | SLO SRO ROL ROR
%  op[30] |   0    0    1 |    1 |   0   0   1   1
%  op[29] |   0    0    0 |    0 |   1   1   1   1
%  funct3 | 001  101  101 |  001 | 001 101 001 101
%
% Unary operations are using the ROLI encoding space.
%
% Other ALU instructions use funct7=0000100 or funct7=0000101.
%
% All ternary instructions use f2=01.
%
% Reserved immediate fields in the table below are large enough to support RV128.

\begin{verbatim}
|  3                   2                   1                    |
|1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0|
|---------------------------------------------------------------|
|    funct7   |   rs2   |   rs1   |  f3 |    rd   |    opcode   |  R-type
|   rs3   | f2|   rs2   |   rs1   |  f3 |    rd   |    opcode   |  R4-type
|          imm          |   rs1   |  f3 |    rd   |    opcode   |  I-type
|---------------------------------------------------------------|
|  0110000       00000  |   rs1   | 001 |    rd   |   0010011   |  CLZ
|  0110000       00001  |   rs1   | 001 |    rd   |   0010011   |  CTZ
|  0110000       00010  |   rs1   | 001 |    rd   |   0010011   |  PCNT
|  0100000    |   rs2   |   rs1   | 111 |    rd   |   0110011   |  ANDC
|  0010000    |   rs2   |   rs1   | 001 |    rd   |   0110011   |  SLO
|  0010000    |   rs2   |   rs1   | 101 |    rd   |   0110011   |  SRO
|  00100  |     imm     |   rs1   | 001 |    rd   |   0010011   |  SLOI
|  00100  |     imm     |   rs1   | 101 |    rd   |   0010011   |  SROI
|  0110000    |   rs2   |   rs1   | 001 |    rd   |   0110011   |  ROL
|  0110000    |   rs2   |   rs1   | 101 |    rd   |   0110011   |  ROR
|  01100  |     imm     |   rs1   | 101 |    rd   |   0010011   |  RORI
|  0100000    |   rs2   |   rs1   | 001 |    rd   |   0110011   |  GREV
|  01000  |     imm     |   rs1   | 001 |    rd   |   0010011   |  GREVI
|  0000100    |   rs2   |   rs1   | 001 |    rd   |   0110011   |  SHFL
|  0000100    |   rs2   |   rs1   | 101 |    rd   |   0110011   |  UNSHFL
|  000010   |    imm    |   rs1   | 001 |    rd   |   0010011   |  SHFLI
|  000010   |    imm    |   rs1   | 101 |    rd   |   0010011   |  UNSHFLI
|  0000100    |   rs2   |   rs1   | 000 |    rd   |   0110011   |  BEXT
|  0000100    |   rs2   |   rs1   | 100 |    rd   |   0110011   |  BDEP
|   rs3   | 10|   rs2   |   rs1   | 010 |    rd   |   0110011   |  CMIX
|   rs3   | 10|   rs2   |   rs1   | 011 |    rd   |   0110011   |  CMOV
|   rs3   | 10|   rs2   |   rs1   | 001 |    rd   |   0110011   |  FSL
|   rs3   | 10|   rs2   |   rs1   | 101 |    rd   |   0110011   |  FSR
|  0000100    |   rs2   |   rs1   | 010 |    rd   |   0110011   |  MIN
|  0000100    |   rs2   |   rs1   | 011 |    rd   |   0110011   |  MINU
|  0000100    |   rs2   |   rs1   | 110 |    rd   |   0110011   |  MAX
|  0000100    |   rs2   |   rs1   | 111 |    rd   |   0110011   |  MAXU
|  0000101    |   rs2   |   rs1   | 000 |    rd   |   0110011   |  CLMUL
|  0000101    |   rs2   |   rs1   | 001 |    rd   |   0110011   |  CLMULH
|  0110000       10000  |   rs1   | 001 |    rd   |   0010011   |  CRC32.B
|  0110000       10001  |   rs1   | 001 |    rd   |   0010011   |  CRC32.H
|  0110000       10010  |   rs1   | 001 |    rd   |   0010011   |  CRC32.W
|  0110000       10011  |   rs1   | 001 |    rd   |   0010011   |  CRC32.D
|  0110000       11000  |   rs1   | 001 |    rd   |   0010011   |  CRC32C.B
|  0110000       11001  |   rs1   | 001 |    rd   |   0010011   |  CRC32C.H
|  0110000       11010  |   rs1   | 001 |    rd   |   0010011   |  CRC32C.W
|  0110000       11011  |   rs1   | 001 |    rd   |   0010011   |  CRC32C.D
|  0000100    |   rs2   |   rs1   | 110 |    rd   |   0110011   |  BMATXOR
|  0000100    |   rs2   |   rs1   | 111 |    rd   |   0110011   |  BMATOR
|  0110000       00011  |   rs1   | 001 |    rd   |   0010011   |  BMATFLIP
|---------------------------------------------------------------|
|  0110000       00000  |   rs1   | 001 |    rd   |   0011011   |  CLZW
|  0110000       00001  |   rs1   | 001 |    rd   |   0011011   |  CTZW
|  0110000       00010  |   rs1   | 001 |    rd   |   0011011   |  PCNTW
|  0010000    |   rs2   |   rs1   | 001 |    rd   |   0111011   |  SLOW
|  0010000    |   rs2   |   rs1   | 101 |    rd   |   0111011   |  SROW
|  0010000    |   imm   |   rs1   | 001 |    rd   |   0011011   |  SLOIW
|  0010000    |   imm   |   rs1   | 101 |    rd   |   0011011   |  SROIW
|  0110000    |   rs2   |   rs1   | 001 |    rd   |   0111011   |  ROLW
|  0110000    |   rs2   |   rs1   | 101 |    rd   |   0111011   |  RORW
|  0110000    |   imm   |   rs1   | 101 |    rd   |   0011011   |  RORIW
|  0000100    |   rs2   |   rs1   | 000 |    rd   |   0111011   |  BEXTW
|  0000100    |   rs2   |   rs1   | 100 |    rd   |   0111011   |  BDEPW
|  0000100    |   rs2   |   rs1   | 010 |    rd   |   0111011   |  MINW
|  0000100    |   rs2   |   rs1   | 011 |    rd   |   0111011   |  MINUW
|  0000100    |   rs2   |   rs1   | 110 |    rd   |   0111011   |  MAXW
|  0000100    |   rs2   |   rs1   | 111 |    rd   |   0111011   |  MAXUW
|  0000101    |   rs2   |   rs1   | 000 |    rd   |   0110011   |  CLMULW
|---------------------------------------------------------------|
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Fast C reference implementations}
\label{fastc}

GCC has intrinsics for the bit counting instructions {\tt clz}, {\tt ctz}, and
{\tt pcnt}.  So a performance-sensitive application (such as an emulator)
should probably just use those:

\input{bextcref-fast-bitcnt}

For processors with BMI2 support GCC has intrinsics for bit extract and bit
deposit instructions (compile with {\tt -mbmi2} and include {\tt <x86intrin.h>}):

\input{bextcref-fast-bext-bmi2}

For other processors we need to provide our own implementations. The following
implementation is a good compromise between code complexity and runtime:

\input{bextcref-fast-bext}

For the other Bitmanip instructions the C reference functions given in Chapter~\ref{bext}
are already reasonably efficient.
