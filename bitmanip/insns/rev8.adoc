[#insns-rev8,reftext="Byte-reverse register"]
=== rev8

Synopsis::
Byte-reverse register

Mnemonic::
rev8 _rd_, _rs_

Encoding (RV32)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5 },
    { bits:  5, name: 'rs' },
    { bits: 12, name: 0x698 }
]}
....

Encoding (RV64)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5 },
    { bits:  5, name: 'rs' },
    { bits: 12, name: 0x6b8 }
]}
....

Description:: 
This instruction reverses the order of the bytes in a register.

Operation::
[source,sail]
--
let input = X(rs);
let output : xlenbits = 0;
let j = xlen;

foreach (i from 0 to xlen by 8) {
   output[i..(i + 7)] = input[(j - 7)..j];
   j = j - 8;
}

X[rd] = output
--

.Architecture Explanation
[NOTE, caption="A" ]
===============================================================
It is important to note that this mnemonic refers to different instruction encodings in RV32 and RV64.
We decided that it was more important to tie the mnemonic to the function rather than the encoding.
This might be confusing to some as this differs from our common practice 
of having the same mnemonic refer to the same encoding across RV32 and RV64. However, in the end we
think that it will be more intuitive.
===============================================================

.Software Hint
[NOTE, caption="SH" ]
===============================================================
The byte-reverse operation is only available for the full register
width.  To emulate word-sized and halfword-sized byte-reversal,
perform a `rev8 rd,rs` followed by a `srai rd,rd`.
===============================================================

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbb (<<#zbb>>)
|0.93
|Frozen
|===

