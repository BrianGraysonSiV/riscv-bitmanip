== Sign- and zero-extension

The idiomatic forms for sign- and zero-extension on RISC-V use a
shift-left followed by either a shift-right-logical or a
shift-right-arithmetic; these can be used to extend values at any
bit-boundary required.

The bitmanipulation-extension defines single-instruction encodings for
the most common sign-extension and zero-extension cases: those
operating on 8-bit, 16bit and 32bit quantities.

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|Mnemonic
|Instruction

|&#10003;
|&#10003;
|sext.b _rd_, _rs_
|xref:insns/sext_b.adoc[Sign-extend an 8-bit quantity]

|&#10003;
|&#10003;
|sext.h _rd_, _rs_
|xref:insns/sext_h.adoc[Sign-extend a 16-bit quantity]

|
|&#10003;
|sext.w _rd_, _rs_
|addiw _rd_, _rs_, 0 (pseudo-instruction)

|&#10003;
|&#10003;
|zext.b _rd_, _rs_
|andi _rd_, _rs_, 255 (pseudo-instruction)

|&#10003;
|&#10003;
|zext.h _rd_, _rs_
|xref:insns/zext_h.adoc[Zero-extend a 16-bit quantity]

|
|&#10003;
|zext.w _rd_, _rs_
|xref:insns/zext_w.adoc[Zero-extend a 32-bit quantity]
|===

NOTE: These instructions replace the generalised idioms `slli
rD,rS,(XLEN-<size>) + srli` (for zero-extension) or `slli + srai` (for
sign-extension) for the sign-extension of 8 bit and 16-bit quantities,
and for the zero-extension off 16 bit and 32 bit quantities.