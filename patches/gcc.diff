diff --git a/gcc/common/config/riscv/riscv-common.c b/gcc/common/config/riscv/riscv-common.c
index eeb75717d..2555589b0 100644
--- a/gcc/common/config/riscv/riscv-common.c
+++ b/gcc/common/config/riscv/riscv-common.c
@@ -568,6 +568,10 @@ riscv_parse_arch_string (const char *isa, int *flags, location_t loc)
   if (subset_list->lookup ("c"))
     *flags |= MASK_RVC;
 
+  *flags &= ~MASK_BITMANIP;
+  if (subset_list->lookup ("b"))
+    *flags |= MASK_BITMANIP;
+
   if (current_subset_list)
     delete current_subset_list;
 
diff --git a/gcc/config/riscv/bitmanip.md b/gcc/config/riscv/bitmanip.md
index e69de29bb..67d5160b1 100644
--- a/gcc/config/riscv/bitmanip.md
+++ b/gcc/config/riscv/bitmanip.md
@@ -0,0 +1,365 @@
+;; Machine description for RISC-V Bit Manipulation operations.
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+(define_code_iterator bitmanip_bitwise [and ior])
+
+(define_code_iterator any_minmax [smin smax umin umax])
+
+(define_code_attr bitmanip_optab [(smin "smin")
+				  (smax "smax")
+				  (umin "umin")
+				  (umax "umax")])
+
+(define_code_attr bitmanip_insn [(smin "min")
+				 (smax "max")
+				 (umin "minu")
+				 (umax "maxu")])
+
+(define_insn "clzsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(clz:SI (match_operand:SI 1 "register_operand" "r")))]
+  "TARGET_BITMANIP"
+  { return TARGET_64BIT ? "clzw\t%0,%1" : "clz\t%0,%1"; }
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "clzdi2"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(clz:DI (match_operand:DI 1 "register_operand" "r")))]
+  "TARGET_64BIT && TARGET_BITMANIP"
+  "clz\t%0,%1"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "ctzsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ctz:SI (match_operand:SI 1 "register_operand" "r")))]
+  "TARGET_BITMANIP"
+  { return TARGET_64BIT ? "ctzw\t%0,%1" : "ctz\t%0,%1"; }
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "ctzdi2"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(ctz:DI (match_operand:DI 1 "register_operand" "r")))]
+  "TARGET_64BIT && TARGET_BITMANIP"
+  "ctz\t%0,%1"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "popcountsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(popcount:SI (match_operand:SI 1 "register_operand" "r")))]
+  "TARGET_BITMANIP"
+  { return TARGET_64BIT ? "pcntw\t%0,%1" : "pcnt\t%0,%1"; }
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "popcountdi2"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(popcount:DI (match_operand:DI 1 "register_operand" "r")))]
+  "TARGET_64BIT && TARGET_BITMANIP"
+  "pcnt\t%0,%1"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*<optab>_not<mode>"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(bitmanip_bitwise:X (not:X (match_operand:X 1 "register_operand" "r"))
+			    (match_operand:X 2 "register_operand" "r")))]
+  "TARGET_BITMANIP"
+  "<insn>n\t%0,%2,%1"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*xor_not<mode>"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(not:X (xor:X (match_operand:X 1 "register_operand" "r")
+		      (match_operand:X 2 "register_operand" "r"))))]
+  "TARGET_BITMANIP"
+  "xnor\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+ 
+;;; ??? pack
+
+;; ??? assembler doesn't support zext.h
+(define_insn "*zero_extendhi<GPR:mode>2_bitmanip"
+  [(set (match_operand:GPR 0 "register_operand" "=r,r")
+	(zero_extend:GPR (match_operand:HI 1 "nonimmediate_operand" "r,m")))]
+  "TARGET_BITMANIP"
+{
+  if (which_alternative == 0)
+   return TARGET_64BIT ? "packw\t%0,%1,x0" : "pack\t%0,%1,x0";
+  else
+   return "lhu\t%0,%1";
+}
+  [(set_attr "type" "bitmanip,load")])
+
+;; ??? assembler doesn't support zext.w
+(define_insn "*zero_extendsidi2_bitmanip"
+  [(set (match_operand:DI 0 "register_operand" "=r,r")
+	(zero_extend:DI (match_operand:SI 1 "nonimmediate_operand" "r,m")))]
+  "TARGET_64BIT && TARGET_BITMANIP"
+  "@
+   pack\t%0,%1,x0
+   lwu\t%0,%1"
+  [(set_attr "type" "bitmanip,load")])
+
+(define_insn "<bitmanip_optab><mode>3"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(any_minmax:X (match_operand:X 1 "register_operand" "r")
+		      (match_operand:X 2 "register_operand" "r")))]
+  "TARGET_BITMANIP"
+  "<bitmanip_insn>\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+;;; ??? check sb*iw
+
+(define_insn "*sbset<mode>"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(ior:X (ashift:X (const_int 1)
+			 (match_operand:QI 2 "register_operand" "=r"))
+	       (match_operand:X 1 "register_operand" "r")))]
+  "TARGET_BITMANIP"
+  "sbset\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbseti<mode>"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(ior:X (match_operand:X 1 "register_operand" "r")
+	       (match_operand 2 "single_bit_mask_operand" "i")))]
+  "TARGET_BITMANIP"
+  "sbseti\t%0,%1,%S2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbsetw"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(sign_extend:DI
+	 (subreg:SI
+	  (ior:DI (subreg:DI
+		   (ashift:SI (const_int 1)
+			      (match_operand:QI 2 "register_operand" "=r")) 0)
+		  (match_operand:DI 1 "register_operand" "r")) 0)))]
+  "TARGET_64BIT && TARGET_BITMANIP"
+  "sbsetw\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbclr<mode>"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(and:X (rotate:X (const_int -2)
+			 (match_operand:QI 2 "register_operand" "=r"))
+	       (match_operand:X 1 "register_operand" "r")))]
+  "TARGET_BITMANIP"
+  "sbclr\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbclri<mode>"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(and:X (match_operand:X 1 "register_operand" "r")
+	       (match_operand 2 "not_single_bit_mask_operand" "i")))]
+  "TARGET_BITMANIP"
+  "sbclri\t%0,%1,%T2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbclrw"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(sign_extend:DI
+	 (subreg:SI
+	  (and:DI
+	   (not:DI (subreg:DI
+		    (ashift:SI (const_int 1)
+			       (match_operand:QI 2 "register_operand" "=r")) 0))
+	   (match_operand:DI 1 "register_operand" "r")) 0)))]
+  "TARGET_64BIT && TARGET_BITMANIP"
+  "sbclrw\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbinv<mode>"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(xor:X (ashift:X (const_int 1)
+			 (match_operand:QI 2 "register_operand" "=r"))
+	       (match_operand:X 1 "register_operand" "r")))]
+  "TARGET_BITMANIP"
+  "sbinv\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbinvi<mode>"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(xor:X (match_operand:X 1 "register_operand" "r")
+	       (match_operand 2 "single_bit_mask_operand" "i")))]
+  "TARGET_BITMANIP"
+  "sbinvi\t%0,%1,%S2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbinvw"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(sign_extend:DI
+	 (subreg:SI
+	  (xor:DI (subreg:DI
+		   (ashift:SI (const_int 1)
+			      (match_operand:QI 2 "register_operand" "=r")) 0)
+		  (match_operand:DI 1 "register_operand" "r")) 0)))]
+  "TARGET_64BIT && TARGET_BITMANIP"
+  "sbinvw\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbext<mode>"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(zero_extract:X (match_operand:X 1 "register_operand" "r")
+			(const_int 1)
+			(zero_extend:X
+			 (match_operand:QI 2 "register_operand" "r"))))]
+  "TARGET_BITMANIP"
+  "sbext\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbexti"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(zero_extract:X (match_operand:X 1 "register_operand" "r")
+			(const_int 1)
+			(match_operand 2 "immediate_operand" "i")))]
+  "TARGET_BITMANIP"
+  "sbexti\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbextw"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(and:DI
+	 (subreg:DI
+	  (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
+		       (match_operand:QI 2 "register_operand" "r")) 0)
+	 (const_int 1)))]
+  "TARGET_64BIT && TARGET_BITMANIP"
+  "sbextw\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+;;; ??? s[lr]o*
+
+(define_insn "rotrsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(rotatert:SI (match_operand:SI 1 "register_operand" "r")
+		     (match_operand:SI 2 "arith_operand" "rI")))]
+  "TARGET_BITMANIP"
+  { return TARGET_64BIT ? "ror%i2w\t%0,%1,%2" : "ror%i2\t%0,%1,%2"; }
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "rotrdi3"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(rotatert:DI (match_operand:DI 1 "register_operand" "r")
+		     (match_operand:DI 2 "arith_operand" "rI")))]
+  "TARGET_64BIT && TARGET_BITMANIP"
+  "ror%i2\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "rotlsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(rotate:SI (match_operand:SI 1 "register_operand" "r")
+		   (match_operand:SI 2 "register_operand" "r")))]
+  "TARGET_BITMANIP"
+  { return TARGET_64BIT ? "rolw\t%0,%1,%2" : "rol\t%0,%1,%2"; }
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "rotldi3"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(rotate:DI (match_operand:DI 1 "register_operand" "r")
+		   (match_operand:DI 2 "register_operand" "r")))]
+  "TARGET_BITMANIP"
+  "rol\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+;;; ??? grev
+
+;;; ??? assembler doesn't accept rev8
+(define_insn "bswapsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(bswap:SI (match_operand:SI 1 "register_operand" "r")))]
+  "TARGET_BITMANIP"
+  { return TARGET_64BIT ? "greviw\t%0,%1,0x18" : "grevi\t%0,%1,0x18"; }
+  [(set_attr "type" "bitmanip")])
+
+;;; ??? assembler doesn't accept rev8
+(define_insn "bswapdi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(bswap:SI (match_operand:SI 1 "register_operand" "r")))]
+  "TARGET_64BIT && TARGET_BITMANIP"
+  "grevi\t%0,%1,0x38"
+  [(set_attr "type" "bitmanip")])
+
+;;; ??? shfl/unshfl
+
+;;; ??? bext/bdep
+
+;;; ??? clmul
+
+;;; ??? crc
+
+;;; ??? bmat
+
+(define_insn "*cmix"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(xor:X (and:X (xor:X (match_operand:X 1 "register_operand" "r")
+			     (match_operand:X 3 "register_operand" "r"))
+		      (match_operand:X 2 "register_operand" "r"))
+	       (match_dup 3)))]
+  "TARGET_BITMANIP"
+  "cmix\t%0,%2,%1,%3"
+  [(set_attr "type" "bitmanip")])
+
+;;; ??? cmov
+
+;;; ??? fs[lr]
+
+(define_insn "*addwu"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI (plus:SI (match_operand:SI 1 "register_operand" "r")
+				 (match_operand:SI 2 "arith_operand" "rI"))))]
+  "TARGET_64BIT && TARGET_BITMANIP"
+  "add%i2wu\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*subwu"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI (minus:SI (match_operand:SI 1 "register_operand" "r")
+				  (match_operand:SI 2 "register_operand" "r"))))]
+  "TARGET_64BIT && TARGET_BITMANIP"
+  "subwu\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*addu.w"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(plus:DI (zero_extend:DI
+		  (subreg:SI (match_operand:DI 2 "register_operand" "r") 0))
+		 (match_operand:DI 1 "register_operand" "r")))]
+  "TARGET_64BIT && TARGET_BITMANIP"
+  "addu.w\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*subu.w"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(minus:DI (match_operand:DI 1 "register_operand" "r")
+		  (zero_extend:DI
+		   (subreg:SI (match_operand:DI 2 "register_operand" "r") 0))))]
+  "TARGET_64BIT && TARGET_BITMANIP"
+  "subu.w\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*slliuw"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(and:DI (ashift:DI (match_operand:DI 1 "register_operand" "r")
+			   (match_operand:QI 2 "immediate_operand" "I"))
+		(match_operand 3 "immediate_operand" "")))]
+  "TARGET_64BIT && TARGET_BITMANIP
+   && (INTVAL (operands[3]) >> INTVAL (operands[2])) == 0xffffffff"
+  "slliu.w\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+;; ??? bfxp
diff --git a/gcc/config/riscv/predicates.md b/gcc/config/riscv/predicates.md
index 83fc4bd66..b7fda628f 100644
--- a/gcc/config/riscv/predicates.md
+++ b/gcc/config/riscv/predicates.md
@@ -68,7 +68,10 @@
 
   /* Otherwise check whether the constant can be loaded in a single
      instruction.  */
-  return !LUI_OPERAND (INTVAL (op)) && !SMALL_OPERAND (INTVAL (op));
+  return (!LUI_OPERAND (INTVAL (op)) && !SMALL_OPERAND (INTVAL (op))
+	  && !(TARGET_64BIT && TARGET_BITMANIP
+	       && (ZERO_EXTENDED_SMALL_OPERAND (INTVAL (op))
+		   || SINGLE_BIT_MASK_OPERAND (INTVAL (op)))));
 })
 
 (define_predicate "p2m1_shift_operand"
@@ -198,3 +201,22 @@
 
 (define_predicate "fp_branch_comparison"
   (match_code "unordered,ordered,unlt,unge,unle,ungt,uneq,ltgt,ne,eq,lt,le,gt,ge"))
+
+;; Predicates for the B extension.
+(define_predicate "single_bit_mask_operand"
+  (match_code "const_int")
+{
+  int val = pow2p_hwi (INTVAL (op));
+  if (val != -1)
+    return true;
+  return false;
+})
+
+(define_predicate "not_single_bit_mask_operand"
+  (match_code "const_int")
+{
+  int val = pow2p_hwi (~INTVAL (op));
+  if (val != -1)
+    return true;
+  return false;
+})
diff --git a/gcc/config/riscv/riscv-builtins.c b/gcc/config/riscv/riscv-builtins.c
index 548267179..fb1a36197 100644
--- a/gcc/config/riscv/riscv-builtins.c
+++ b/gcc/config/riscv/riscv-builtins.c
@@ -84,6 +84,7 @@ struct riscv_builtin_description {
   unsigned int (*avail) (void);
 };
 
+AVAIL (bitmanip64, TARGET_64BIT && TARGET_BITMANIP)
 AVAIL (hard_float, TARGET_HARD_FLOAT)
 
 /* Construct a riscv_builtin_description from the given arguments.
@@ -118,6 +119,7 @@ AVAIL (hard_float, TARGET_HARD_FLOAT)
 /* Argument types.  */
 #define RISCV_ATYPE_VOID void_type_node
 #define RISCV_ATYPE_USI unsigned_intSI_type_node
+#define RISCV_ATYPE_SI intSI_type_node
 
 /* RISCV_FTYPE_ATYPESN takes N RISCV_FTYPES-like type codes and lists
    their associated RISCV_ATYPEs.  */
@@ -125,6 +127,7 @@ AVAIL (hard_float, TARGET_HARD_FLOAT)
   RISCV_ATYPE_##A, RISCV_ATYPE_##B
 
 static const struct riscv_builtin_description riscv_builtins[] = {
+  DIRECT_BUILTIN (pcntw, RISCV_SI_FTYPE_SI, bitmanip64),
   DIRECT_BUILTIN (frflags, RISCV_USI_FTYPE_VOID, hard_float),
   DIRECT_NO_TARGET_BUILTIN (fsflags, RISCV_VOID_FTYPE_USI, hard_float)
 };
diff --git a/gcc/config/riscv/riscv-ftypes.def b/gcc/config/riscv/riscv-ftypes.def
index eefe3033e..f91dac7d2 100644
--- a/gcc/config/riscv/riscv-ftypes.def
+++ b/gcc/config/riscv/riscv-ftypes.def
@@ -28,3 +28,4 @@ along with GCC; see the file COPYING3.  If not see
 
 DEF_RISCV_FTYPE (1, (USI, VOID))
 DEF_RISCV_FTYPE (1, (VOID, USI))
+DEF_RISCV_FTYPE (1, (SI, SI))
diff --git a/gcc/config/riscv/riscv.c b/gcc/config/riscv/riscv.c
index e7440f390..89fc181a1 100644
--- a/gcc/config/riscv/riscv.c
+++ b/gcc/config/riscv/riscv.c
@@ -374,6 +374,27 @@ riscv_build_integer_1 (struct riscv_integer_op codes[RISCV_MAX_INTEGER_OPS],
       return 1;
     }
 
+  /* ??? Maybe there are also other bitmanip instructions useful for loading
+     constants?  */
+  if (TARGET_64BIT && TARGET_BITMANIP)
+    {
+      if (ZERO_EXTENDED_SMALL_OPERAND (value))
+	{
+	  /* Simply ADDIWU.  */
+	  codes[0].code = UNKNOWN;
+	  codes[0].value = value;
+	  return 1;
+	}
+      else if (SINGLE_BIT_MASK_OPERAND (value))
+	{
+	  /* Simply SBSET.  */
+	  codes[0].code = UNKNOWN;
+	  codes[0].value = value;
+	  return 1;
+	}
+      /* ??? Can use slo/sro to load constants.  */
+    }
+
   /* End with ADDI.  When constructing HImode constants, do not generate any
      intermediate value that is not itself a valid HImode constant.  The
      XORI case below will handle those remaining HImode constants.  */
@@ -1601,12 +1622,21 @@ riscv_rtx_costs (rtx x, machine_mode mode, int outer_code, int opno ATTRIBUTE_UN
 
     case ZERO_EXTRACT:
       /* This is an SImode shift.  */
-      if (outer_code == SET && (INTVAL (XEXP (x, 2)) > 0)
+      if (outer_code == SET && GET_CODE (XEXP (x, 2)) == CONST_INT
+	  && (INTVAL (XEXP (x, 2)) > 0) && GET_CODE (XEXP (x, 1)) == CONST_INT
 	  && (INTVAL (XEXP (x, 1)) + INTVAL (XEXP (x, 2)) == 32))
 	{
 	  *total = COSTS_N_INSNS (SINGLE_SHIFT_COST);
 	  return true;
 	}
+      /* This is an sbext.  */
+      if (TARGET_BITMANIP && outer_code == SET
+	  && GET_CODE (XEXP (x, 1)) == CONST_INT
+	  && INTVAL (XEXP (x, 1)) == 1)
+	{
+	  *total = COSTS_N_INSNS (SINGLE_SHIFT_COST);
+	  return true;
+	}
       return false;
 
     case ASHIFT:
@@ -1885,7 +1915,21 @@ riscv_output_move (rtx dest, rtx src)
 	  }
 
       if (src_code == CONST_INT)
-	return "li\t%0,%1";
+	{
+	  if (SMALL_OPERAND (INTVAL (src)) || LUI_OPERAND (INTVAL (src)))
+	    return "li\t%0,%1";
+
+	  if (TARGET_BITMANIP && TARGET_64BIT)
+	    {
+	      if (ZERO_EXTENDED_SMALL_OPERAND (INTVAL (src)))
+		return "addiwu\t%0,zero,%s1";
+	      if (SINGLE_BIT_MASK_OPERAND (INTVAL (src)))
+		return "sbseti\t%0,zero,%S1";
+	    }
+
+	  /* Should never reach here.  */
+	  abort ();
+	}
 
       if (src_code == HIGH)
 	return "lui\t%0,%h1";
@@ -3147,7 +3191,9 @@ riscv_memmodel_needs_release_fence (enum memmodel model)
    'A'	Print the atomic operation suffix for memory model OP.
    'F'	Print a FENCE if the memory model requires a release.
    'z'	Print x0 if OP is zero, otherwise print OP normally.
-   'i'	Print i if the operand is not a register.  */
+   'i'	Print i if the operand is not a register.
+   's'  Sign-extend a 32-bit constant value to 64-bits then print.
+   'S'  Print shift-index of single-bit mask OP.  */
 
 static void
 riscv_print_operand (FILE *file, rtx op, int letter)
@@ -3187,6 +3233,27 @@ riscv_print_operand (FILE *file, rtx op, int letter)
         fputs ("i", file);
       break;
 
+    case 's':
+      {
+	rtx newop = GEN_INT (INTVAL (op) | 0xffffffffUL << 32);
+	output_addr_const (file, newop);
+	break;
+      }
+
+    case 'S':
+      {
+	rtx newop = GEN_INT (ctz_hwi (INTVAL (op)));
+	output_addr_const (file, newop);
+	break;
+      }
+
+    case 'T':
+      {
+	rtx newop = GEN_INT (ctz_hwi (~INTVAL (op)));
+	output_addr_const (file, newop);
+	break;
+      }
+	
     default:
       switch (code)
 	{
diff --git a/gcc/config/riscv/riscv.h b/gcc/config/riscv/riscv.h
index c93743f95..40da6530f 100644
--- a/gcc/config/riscv/riscv.h
+++ b/gcc/config/riscv/riscv.h
@@ -456,6 +456,18 @@ enum reg_class
   (((VALUE) | ((1UL<<31) - IMM_REACH)) == ((1UL<<31) - IMM_REACH)	\
    || ((VALUE) | ((1UL<<31) - IMM_REACH)) + IMM_REACH == 0)
 
+/* The following macros use B extension instructions to load constants.  */
+
+/* If this is a negative 32-bit value zero-extended to 64-bits, then we
+   can load it with addiwu if it is close enough to -1.  */
+#define ZERO_EXTENDED_SMALL_OPERAND(VALUE) \
+  (((VALUE & 0xffffffff) == VALUE) && (VALUE & 0x80000000)		\
+   && SMALL_OPERAND (VALUE | (0xffffffffUL << 32)))
+
+/* If this is a single bit mask, then we can load it with sbseti.  */
+#define SINGLE_BIT_MASK_OPERAND(VALUE) \
+  (pow2p_hwi (VALUE))
+
 /* Stack layout; function entry, exit and calling.  */
 
 #define STACK_GROWS_DOWNWARD 1
@@ -664,6 +676,13 @@ typedef struct {
 
 #define LOGICAL_OP_NON_SHORT_CIRCUIT 0
 
+/* Configure CLZ/CTZ behavior. */
+
+#define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) \
+  ((VALUE) = GET_MODE_UNIT_BITSIZE (MODE), 2)
+#define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) \
+  ((VALUE) = GET_MODE_UNIT_BITSIZE (MODE), 2)
+
 /* Control the assembler format that we output.  */
 
 /* Output to assembler file text saying following lines
diff --git a/gcc/config/riscv/riscv.md b/gcc/config/riscv/riscv.md
index e3799a5bd..33668a48e 100644
--- a/gcc/config/riscv/riscv.md
+++ b/gcc/config/riscv/riscv.md
@@ -43,6 +43,9 @@
   UNSPEC_LRINT
   UNSPEC_LROUND
 
+  ;; Bitmanip
+  UNSPEC_PCNTW
+
   ;; Stack tie
   UNSPEC_TIE
 ])
@@ -156,7 +159,7 @@
 (define_attr "type"
   "unknown,branch,jump,call,load,fpload,store,fpstore,
    mtc,mfc,const,arith,logical,shift,slt,imul,idiv,move,fmove,fadd,fmul,
-   fmadd,fdiv,fcmp,fcvt,fsqrt,multi,auipc,nop,ghost"
+   fmadd,fdiv,fcmp,fcvt,fsqrt,multi,auipc,nop,ghost,bitmanip"
   (cond [(eq_attr "got" "load") (const_string "load")
 
 	 ;; If a doubleword move uses these expensive instructions,
@@ -1043,11 +1046,16 @@
 
 ;; Extension insns.
 
-(define_insn_and_split "zero_extendsidi2"
+(define_expand "zero_extendsidi2"
+  [(set (match_operand:DI 0 "register_operand")
+	(zero_extend:DI (match_operand:SI 1 "nonimmediate_operand")))]
+  "TARGET_64BIT")
+
+(define_insn_and_split "*zero_extendsidi2_internal"
   [(set (match_operand:DI     0 "register_operand"     "=r,r")
 	(zero_extend:DI
 	    (match_operand:SI 1 "nonimmediate_operand" " r,m")))]
-  "TARGET_64BIT"
+  "TARGET_64BIT && !TARGET_BITMANIP"
   "@
    #
    lwu\t%0,%1"
@@ -1060,11 +1068,15 @@
   [(set_attr "move_type" "shift_shift,load")
    (set_attr "mode" "DI")])
 
-(define_insn_and_split "zero_extendhi<GPR:mode>2"
+(define_expand "zero_extendhi<GPR:mode>2"
+  [(set (match_operand:GPR 0 "register_operand")
+	(zero_extend:GPR (match_operand:HI 1 "nonimmediate_operand")))])
+
+(define_insn_and_split "*zero_extendhi<GPR:mode>2_internal"
   [(set (match_operand:GPR    0 "register_operand"     "=r,r")
 	(zero_extend:GPR
 	    (match_operand:HI 1 "nonimmediate_operand" " r,m")))]
-  ""
+  "!TARGET_BITMANIP"
   "@
    #
    lhu\t%0,%1"
@@ -2389,6 +2401,14 @@
   ""
   "")
 
+(define_insn "riscv_pcntw"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec
+	    [(match_operand:SI 1 "register_operand" "r")]
+	    UNSPEC_PCNTW))]
+  ""
+  "pcntw\t%0,%1")
+
 (define_insn "riscv_frflags"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(unspec_volatile [(const_int 0)] UNSPECV_FRFLAGS))]
@@ -2450,3 +2470,4 @@
 (include "pic.md")
 (include "generic.md")
 (include "sifive-7.md")
+(include "bitmanip.md")
diff --git a/gcc/config/riscv/riscv.opt b/gcc/config/riscv/riscv.opt
index 3b25f9a10..2be866d20 100644
--- a/gcc/config/riscv/riscv.opt
+++ b/gcc/config/riscv/riscv.opt
@@ -118,6 +118,8 @@ Mask(64BIT)
 
 Mask(MUL)
 
+Mask(BITMANIP)
+
 Mask(ATOMIC)
 
 Mask(HARD_FLOAT)
