diff --git a/gcc/common/config/riscv/riscv-common.c b/gcc/common/config/riscv/riscv-common.c
index eeb75717d..a33edbd57 100644
--- a/gcc/common/config/riscv/riscv-common.c
+++ b/gcc/common/config/riscv/riscv-common.c
@@ -73,6 +73,8 @@ private:
   const char *parse_sv_or_non_std_ext (const char *, const char *,
 				       const char *);
 
+  const char *parse_bitmanip_ext (const char *);
+
 public:
   ~riscv_subset_list ();
 
@@ -395,6 +397,20 @@ riscv_subset_list::parse_std_ext (const char *p)
       subset[0] = std_ext;
 
       add (subset, major_version, minor_version);
+
+      /* Parse any additional ISA subset selectors. */
+      switch (std_ext)
+	{
+	case 'b':
+	  p = parse_bitmanip_ext (p);
+	  break;
+
+	default:
+	  break;
+	}
+
+      if (!p)
+	return NULL;
     }
   return p;
 }
@@ -464,6 +480,139 @@ riscv_subset_list::parse_sv_or_non_std_ext (const char *p,
   return p;
 }
 
+static int
+riscv_bitmanip_ext_suffix_p (char ch)
+{
+  switch (ch)
+    {
+    case 'b':
+    case 'c':
+    case 'e':
+    case 'f':
+    case 'm':
+    case 'p':
+    case 'r':
+    case 's':
+    case 't':
+      return 1;
+
+    default:
+      return 0;
+    }
+}
+
+static long int
+riscv_bitmanip_ext_mask (char ch)
+{
+  switch (ch)
+    {
+    case 'b': return OPTION_MASK_BITMANIP_ZBB;
+    case 'c': return OPTION_MASK_BITMANIP_ZBC;
+    case 'e': return OPTION_MASK_BITMANIP_ZBE;
+    case 'f': return OPTION_MASK_BITMANIP_ZBF;
+    case 'm': return OPTION_MASK_BITMANIP_ZBM;
+    case 'p': return OPTION_MASK_BITMANIP_ZBP;
+    case 'r': return OPTION_MASK_BITMANIP_ZBR;
+    case 's': return OPTION_MASK_BITMANIP_ZBS;
+    case 't': return OPTION_MASK_BITMANIP_ZBT;
+    default:
+      gcc_unreachable ();
+      return 0;
+    }
+}
+
+static int
+riscv_bitmanip_ext_index (char ch)
+{
+  long int mask = riscv_bitmanip_ext_mask (ch);
+  return ctz_hwi (mask);
+}
+
+const char * const *
+riscv_bitmanip_ext_strtab (void)
+{
+  static const char * const strtab[] =
+    {
+     "Zbb", "Zbc", "Zbe", "Zbf",
+     "Zbm", "Zbp", "Zbr", "Zbs",
+     "Zbt",
+
+     NULL
+    };
+
+  return strtab;
+}
+
+static int
+riscv_bitmanip_ext_count (void)
+{
+  int count = 0;
+  const char * const *ext = riscv_bitmanip_ext_strtab ();
+
+  for (; *ext; ext++, count++);
+
+  return count;
+}
+
+/* Parsing function for bitmanip `Zb{b,c,e,f,m,p,r,s,t}` extensions.
+
+   Return Value:
+     Points to the end of extensions.
+
+   Arguments:
+   `p`: Current parsing position. */
+
+const char *
+riscv_subset_list::parse_bitmanip_ext (const char *p)
+{
+  const char * const * ext_tab = riscv_bitmanip_ext_strtab ();
+
+  unsigned int major_version = 0;
+  unsigned int minor_version = 0;
+  const char *ext = NULL;
+  char buffer[4] = {0, 0, 0, '\0'};
+
+  while (1) {
+    if (*p == '_')
+      {
+	p++;
+	continue;
+      }
+
+    strncpy (buffer, p, 3);
+
+    /* Assert that this is a known bitmanip extension. */
+    if ( strlen (buffer) < 3
+	 || !(p[0] == 'Z'
+	      && p[1] == 'b'
+	      && riscv_bitmanip_ext_suffix_p (p[2])) )
+      {
+	return p;
+      }
+
+    /* Ok, we have a valid bitmanip extension. Select it. */
+    ext = ext_tab[ riscv_bitmanip_ext_index (p[2]) ];
+
+    /* Try to get the version string, if there is one. */
+    p += 3;
+    p = parsing_subset_version (p, &major_version, &minor_version,
+				/* default_major_version= */ 2,
+				/* default_minor_version= */ 0,
+				/* std_ext_p= */ FALSE);
+
+    /* Check that if this isn't conjoined with another extension,
+       e.g. "ZbmZbt" */
+    if (*p != '\0' && *p != '_')
+      {
+	error_at (m_loc, "%<-march=%s%>: %s must separate with _",
+		  m_arch, buffer);
+	return NULL;
+      }
+
+    add (ext, major_version, minor_version);
+  }
+}
+
 /* Parsing arch string to subset list, return NULL if parsing failed.  */
 
 riscv_subset_list *
@@ -529,13 +678,62 @@ riscv_arch_str ()
   return current_subset_list->to_string ();
 }
 
+/* Returns true if we have atleast one "Zbx" bitmanip ISA subset selector
+   present in the `-march` directive, and false otherwise. */
+
+static int
+riscv_bitmanip_have_ext_string_p (struct gcc_options *opts,
+				  riscv_subset_list *subset_list)
+{
+  const char * const * ext_tab = riscv_bitmanip_ext_strtab ();
+
+  int count = riscv_bitmanip_ext_count ();
+
+  for (int i = 0; i < count; ++i)
+    {
+      if (subset_list->lookup (ext_tab[i]))
+	return 1;
+    }
+
+  return 0;
+}
+
+/* Check if any of the bitmanip ISA subset selectors are set,
+   and if so set the appropriate bit in the `x->riscv_bitmanip_flags` mask. */
+
+static void
+riscv_parse_bitmanip_ext_string (struct gcc_options *opts,
+				 riscv_subset_list *subset_list)
+{
+  const char * const * ext_tab = riscv_bitmanip_ext_strtab ();
+  long int mask = 0;
+
+  int count = riscv_bitmanip_ext_count ();
+
+  for (int i = 0; i < count; ++i)
+    {
+      if (subset_list->lookup (ext_tab[i]))
+	{
+	  mask = (1ULL << i);
+	  opts->x_riscv_bitmanip_flags |= mask;
+	}
+    }
+}
+
 /* Parse a RISC-V ISA string into an option mask.  Must clear or set all arch
    dependent mask bits, in case more than one -march string is passed.  */
 
 static void
-riscv_parse_arch_string (const char *isa, int *flags, location_t loc)
+riscv_parse_arch_string (const char *isa, struct gcc_options *opts, location_t loc)
 {
   riscv_subset_list *subset_list;
+
+  /* Standard ISA specifiers. */
+  int *flags = &opts->x_target_flags;
+
+  /* Bitmanip ISA specifiers. */
+  long int *bitmanip_flags = &opts->x_riscv_bitmanip_flags;
+
   subset_list = riscv_subset_list::parse (isa, loc);
   if (!subset_list)
     return;
@@ -568,6 +766,31 @@ riscv_parse_arch_string (const char *isa, int *flags, location_t loc)
   if (subset_list->lookup ("c"))
     *flags |= MASK_RVC;
 
+  *flags &= ~MASK_BITMANIP;
+  *bitmanip_flags = 0;
+  if (subset_list->lookup ("b"))
+    {
+      *flags |= MASK_BITMANIP;
+      *bitmanip_flags |= OPTION_MASK_BITMANIP_ZBB;
+      *bitmanip_flags |= OPTION_MASK_BITMANIP_ZBC;
+      *bitmanip_flags |= OPTION_MASK_BITMANIP_ZBE;
+      *bitmanip_flags &= ~OPTION_MASK_BITMANIP_ZBF;
+      *bitmanip_flags |= OPTION_MASK_BITMANIP_ZBM;
+      *bitmanip_flags |= OPTION_MASK_BITMANIP_ZBP;
+      *bitmanip_flags |= OPTION_MASK_BITMANIP_ZBR;
+      *bitmanip_flags |= OPTION_MASK_BITMANIP_ZBS;
+      *bitmanip_flags &= ~OPTION_MASK_BITMANIP_ZBT;
+    }
+
+  /* Check if we were passed any bitmanip extensions separately.
+     If true, then clear all the bitmanip flags and start over,
+     assuming that the user wants fine-grained subset control. */
+  if (riscv_bitmanip_have_ext_string_p (opts, subset_list))
+    {
+      *bitmanip_flags = 0;
+      riscv_parse_bitmanip_ext_string (opts, subset_list);
+    }
+
   if (current_subset_list)
     delete current_subset_list;
 
@@ -585,7 +808,7 @@ riscv_handle_option (struct gcc_options *opts,
   switch (decoded->opt_index)
     {
     case OPT_march_:
-      riscv_parse_arch_string (decoded->arg, &opts->x_target_flags, loc);
+      riscv_parse_arch_string (decoded->arg, opts, loc);
       return true;
 
     default:
diff --git a/gcc/config/riscv/bitmanip.md b/gcc/config/riscv/bitmanip.md
index e69de29bb..66a5b7903 100644
--- a/gcc/config/riscv/bitmanip.md
+++ b/gcc/config/riscv/bitmanip.md
@@ -0,0 +1,365 @@
+;; Machine description for RISC-V Bit Manipulation operations.
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+(define_code_iterator bitmanip_bitwise [and ior])
+
+(define_code_iterator any_minmax [smin smax umin umax])
+
+(define_code_attr bitmanip_optab [(smin "smin")
+				  (smax "smax")
+				  (umin "umin")
+				  (umax "umax")])
+
+(define_code_attr bitmanip_insn [(smin "min")
+				 (smax "max")
+				 (umin "minu")
+				 (umax "maxu")])
+
+(define_insn "clzsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(clz:SI (match_operand:SI 1 "register_operand" "r")))]
+  "TARGET_BITMANIP_ZBB"
+  { return TARGET_64BIT ? "clzw\t%0,%1" : "clz\t%0,%1"; }
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "clzdi2"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(clz:DI (match_operand:DI 1 "register_operand" "r")))]
+  "TARGET_64BIT && TARGET_BITMANIP_ZBB"
+  "clz\t%0,%1"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "ctzsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ctz:SI (match_operand:SI 1 "register_operand" "r")))]
+  "TARGET_BITMANIP_ZBB"
+  { return TARGET_64BIT ? "ctzw\t%0,%1" : "ctz\t%0,%1"; }
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "ctzdi2"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(ctz:DI (match_operand:DI 1 "register_operand" "r")))]
+  "TARGET_64BIT && TARGET_BITMANIP_ZBB"
+  "ctz\t%0,%1"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "popcountsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(popcount:SI (match_operand:SI 1 "register_operand" "r")))]
+  "TARGET_BITMANIP_ZBB"
+  { return TARGET_64BIT ? "pcntw\t%0,%1" : "pcnt\t%0,%1"; }
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "popcountdi2"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(popcount:DI (match_operand:DI 1 "register_operand" "r")))]
+  "TARGET_64BIT && TARGET_BITMANIP_ZBB"
+  "pcnt\t%0,%1"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*<optab>_not<mode>"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(bitmanip_bitwise:X (not:X (match_operand:X 1 "register_operand" "r"))
+			    (match_operand:X 2 "register_operand" "r")))]
+  "TARGET_BITMANIP_ZBB || TARGET_BITMANIP_ZBP"
+  "<insn>n\t%0,%2,%1"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*xor_not<mode>"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(not:X (xor:X (match_operand:X 1 "register_operand" "r")
+		      (match_operand:X 2 "register_operand" "r"))))]
+  "TARGET_BITMANIP_ZBB || TARGET_BITMANIP_ZBP"
+  "xnor\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+ 
+;;; ??? pack
+
+;; ??? assembler doesn't support zext.h
+(define_insn "*zero_extendhi<GPR:mode>2_bitmanip"
+  [(set (match_operand:GPR 0 "register_operand" "=r,r")
+	(zero_extend:GPR (match_operand:HI 1 "nonimmediate_operand" "r,m")))]
+  "TARGET_BITMANIP_ZBB || TARGET_BITMANIP_ZBP"
+{
+  if (which_alternative == 0)
+   return TARGET_64BIT ? "packw\t%0,%1,x0" : "pack\t%0,%1,x0";
+  else
+   return "lhu\t%0,%1";
+}
+  [(set_attr "type" "bitmanip,load")])
+
+;; ??? assembler doesn't support zext.w
+(define_insn "*zero_extendsidi2_bitmanip"
+  [(set (match_operand:DI 0 "register_operand" "=r,r")
+	(zero_extend:DI (match_operand:SI 1 "nonimmediate_operand" "r,m")))]
+  "TARGET_64BIT && (TARGET_BITMANIP_ZBB || TARGET_BITMANIP_ZBP)"
+  "@
+   pack\t%0,%1,x0
+   lwu\t%0,%1"
+  [(set_attr "type" "bitmanip,load")])
+
+(define_insn "<bitmanip_optab><mode>3"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(any_minmax:X (match_operand:X 1 "register_operand" "r")
+		      (match_operand:X 2 "register_operand" "r")))]
+  "TARGET_BITMANIP_ZBB"
+  "<bitmanip_insn>\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+;;; ??? check sb*iw
+
+(define_insn "*sbset<mode>"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(ior:X (ashift:X (const_int 1)
+			 (match_operand:QI 2 "register_operand" "=r"))
+	       (match_operand:X 1 "register_operand" "r")))]
+  "TARGET_BITMANIP_ZBS"
+  "sbset\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbseti<mode>"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(ior:X (match_operand:X 1 "register_operand" "r")
+	       (match_operand 2 "single_bit_mask_operand" "i")))]
+  "TARGET_BITMANIP_ZBS"
+  "sbseti\t%0,%1,%S2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbsetw"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(sign_extend:DI
+	 (subreg:SI
+	  (ior:DI (subreg:DI
+		   (ashift:SI (const_int 1)
+			      (match_operand:QI 2 "register_operand" "=r")) 0)
+		  (match_operand:DI 1 "register_operand" "r")) 0)))]
+  "TARGET_64BIT && TARGET_BITMANIP_ZBS"
+  "sbsetw\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbclr<mode>"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(and:X (rotate:X (const_int -2)
+			 (match_operand:QI 2 "register_operand" "=r"))
+	       (match_operand:X 1 "register_operand" "r")))]
+  "TARGET_BITMANIP_ZBS"
+  "sbclr\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbclri<mode>"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(and:X (match_operand:X 1 "register_operand" "r")
+	       (match_operand 2 "not_single_bit_mask_operand" "i")))]
+  "TARGET_BITMANIP_ZBS"
+  "sbclri\t%0,%1,%T2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbclrw"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(sign_extend:DI
+	 (subreg:SI
+	  (and:DI
+	   (not:DI (subreg:DI
+		    (ashift:SI (const_int 1)
+			       (match_operand:QI 2 "register_operand" "=r")) 0))
+	   (match_operand:DI 1 "register_operand" "r")) 0)))]
+  "TARGET_64BIT && TARGET_BITMANIP_ZBS"
+  "sbclrw\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbinv<mode>"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(xor:X (ashift:X (const_int 1)
+			 (match_operand:QI 2 "register_operand" "=r"))
+	       (match_operand:X 1 "register_operand" "r")))]
+  "TARGET_BITMANIP_ZBS"
+  "sbinv\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbinvi<mode>"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(xor:X (match_operand:X 1 "register_operand" "r")
+	       (match_operand 2 "single_bit_mask_operand" "i")))]
+  "TARGET_BITMANIP_ZBS"
+  "sbinvi\t%0,%1,%S2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbinvw"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(sign_extend:DI
+	 (subreg:SI
+	  (xor:DI (subreg:DI
+		   (ashift:SI (const_int 1)
+			      (match_operand:QI 2 "register_operand" "=r")) 0)
+		  (match_operand:DI 1 "register_operand" "r")) 0)))]
+  "TARGET_64BIT && TARGET_BITMANIP_ZBS"
+  "sbinvw\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbext<mode>"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(zero_extract:X (match_operand:X 1 "register_operand" "r")
+			(const_int 1)
+			(zero_extend:X
+			 (match_operand:QI 2 "register_operand" "r"))))]
+  "TARGET_BITMANIP_ZBS"
+  "sbext\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbexti"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(zero_extract:X (match_operand:X 1 "register_operand" "r")
+			(const_int 1)
+			(match_operand 2 "immediate_operand" "i")))]
+  "TARGET_BITMANIP_ZBS"
+  "sbexti\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*sbextw"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(and:DI
+	 (subreg:DI
+	  (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
+		       (match_operand:QI 2 "register_operand" "r")) 0)
+	 (const_int 1)))]
+  "TARGET_64BIT && TARGET_BITMANIP_ZBS"
+  "sbextw\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+;;; ??? s[lr]o*
+
+(define_insn "rotrsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(rotatert:SI (match_operand:SI 1 "register_operand" "r")
+		     (match_operand:SI 2 "arith_operand" "rI")))]
+  "TARGET_BITMANIP_ZBB || TARGET_BITMANIP_ZBP"
+  { return TARGET_64BIT ? "ror%i2w\t%0,%1,%2" : "ror%i2\t%0,%1,%2"; }
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "rotrdi3"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(rotatert:DI (match_operand:DI 1 "register_operand" "r")
+		     (match_operand:DI 2 "arith_operand" "rI")))]
+  "TARGET_64BIT && (TARGET_BITMANIP_ZBB || TARGET_BITMANIP_ZBP)"
+  "ror%i2\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "rotlsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(rotate:SI (match_operand:SI 1 "register_operand" "r")
+		   (match_operand:SI 2 "register_operand" "r")))]
+  "TARGET_BITMANIP_ZBB || TARGET_BITMANIP_ZBP"
+  { return TARGET_64BIT ? "rolw\t%0,%1,%2" : "rol\t%0,%1,%2"; }
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "rotldi3"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(rotate:DI (match_operand:DI 1 "register_operand" "r")
+		   (match_operand:DI 2 "register_operand" "r")))]
+  "TARGET_BITMANIP_ZBB || TARGET_BITMANIP_ZBP"
+  "rol\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+;;; ??? grev
+
+;;; ??? assembler doesn't accept rev8
+(define_insn "bswapsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(bswap:SI (match_operand:SI 1 "register_operand" "r")))]
+  "TARGET_BITMANIP_ZBP"
+  { return TARGET_64BIT ? "greviw\t%0,%1,0x18" : "grevi\t%0,%1,0x18"; }
+  [(set_attr "type" "bitmanip")])
+
+;;; ??? assembler doesn't accept rev8
+(define_insn "bswapdi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(bswap:SI (match_operand:SI 1 "register_operand" "r")))]
+  "TARGET_64BIT && TARGET_BITMANIP_ZBP"
+  "grevi\t%0,%1,0x38"
+  [(set_attr "type" "bitmanip")])
+
+;;; ??? shfl/unshfl
+
+;;; ??? bext/bdep
+
+;;; ??? clmul
+
+;;; ??? crc
+
+;;; ??? bmat
+
+(define_insn "*cmix"
+  [(set (match_operand:X 0 "register_operand" "=r")
+	(xor:X (and:X (xor:X (match_operand:X 1 "register_operand" "r")
+			     (match_operand:X 3 "register_operand" "r"))
+		      (match_operand:X 2 "register_operand" "r"))
+	       (match_dup 3)))]
+  "TARGET_BITMANIP_ZBT"
+  "cmix\t%0,%2,%1,%3"
+  [(set_attr "type" "bitmanip")])
+
+;;; ??? cmov
+
+;;; ??? fs[lr]
+
+(define_insn "*addwu"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI (plus:SI (match_operand:SI 1 "register_operand" "r")
+				 (match_operand:SI 2 "arith_operand" "rI"))))]
+  "TARGET_64BIT && TARGET_BITMANIP_ZBB"
+  "add%i2wu\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*subwu"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI (minus:SI (match_operand:SI 1 "register_operand" "r")
+				  (match_operand:SI 2 "register_operand" "r"))))]
+  "TARGET_64BIT && TARGET_BITMANIP_ZBB"
+  "subwu\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*addu.w"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(plus:DI (zero_extend:DI
+		  (subreg:SI (match_operand:DI 2 "register_operand" "r") 0))
+		 (match_operand:DI 1 "register_operand" "r")))]
+  "TARGET_64BIT && TARGET_BITMANIP_ZBB"
+  "addu.w\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*subu.w"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(minus:DI (match_operand:DI 1 "register_operand" "r")
+		  (zero_extend:DI
+		   (subreg:SI (match_operand:DI 2 "register_operand" "r") 0))))]
+  "TARGET_64BIT && TARGET_BITMANIP_ZBB"
+  "subu.w\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+(define_insn "*slliuw"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(and:DI (ashift:DI (match_operand:DI 1 "register_operand" "r")
+			   (match_operand:QI 2 "immediate_operand" "I"))
+		(match_operand 3 "immediate_operand" "")))]
+  "TARGET_64BIT && TARGET_BITMANIP_ZBB
+   && (INTVAL (operands[3]) >> INTVAL (operands[2])) == 0xffffffff"
+  "slliu.w\t%0,%1,%2"
+  [(set_attr "type" "bitmanip")])
+
+;; ??? bfxp
diff --git a/gcc/config/riscv/predicates.md b/gcc/config/riscv/predicates.md
index 83fc4bd66..b7fda628f 100644
--- a/gcc/config/riscv/predicates.md
+++ b/gcc/config/riscv/predicates.md
@@ -68,7 +68,10 @@
 
   /* Otherwise check whether the constant can be loaded in a single
      instruction.  */
-  return !LUI_OPERAND (INTVAL (op)) && !SMALL_OPERAND (INTVAL (op));
+  return (!LUI_OPERAND (INTVAL (op)) && !SMALL_OPERAND (INTVAL (op))
+	  && !(TARGET_64BIT && TARGET_BITMANIP
+	       && (ZERO_EXTENDED_SMALL_OPERAND (INTVAL (op))
+		   || SINGLE_BIT_MASK_OPERAND (INTVAL (op)))));
 })
 
 (define_predicate "p2m1_shift_operand"
@@ -198,3 +201,22 @@
 
 (define_predicate "fp_branch_comparison"
   (match_code "unordered,ordered,unlt,unge,unle,ungt,uneq,ltgt,ne,eq,lt,le,gt,ge"))
+
+;; Predicates for the B extension.
+(define_predicate "single_bit_mask_operand"
+  (match_code "const_int")
+{
+  int val = pow2p_hwi (INTVAL (op));
+  if (val != -1)
+    return true;
+  return false;
+})
+
+(define_predicate "not_single_bit_mask_operand"
+  (match_code "const_int")
+{
+  int val = pow2p_hwi (~INTVAL (op));
+  if (val != -1)
+    return true;
+  return false;
+})
diff --git a/gcc/config/riscv/riscv-builtins.c b/gcc/config/riscv/riscv-builtins.c
index 548267179..fb1a36197 100644
--- a/gcc/config/riscv/riscv-builtins.c
+++ b/gcc/config/riscv/riscv-builtins.c
@@ -84,6 +84,7 @@ struct riscv_builtin_description {
   unsigned int (*avail) (void);
 };
 
+AVAIL (bitmanip64, TARGET_64BIT && TARGET_BITMANIP)
 AVAIL (hard_float, TARGET_HARD_FLOAT)
 
 /* Construct a riscv_builtin_description from the given arguments.
@@ -118,6 +119,7 @@ AVAIL (hard_float, TARGET_HARD_FLOAT)
 /* Argument types.  */
 #define RISCV_ATYPE_VOID void_type_node
 #define RISCV_ATYPE_USI unsigned_intSI_type_node
+#define RISCV_ATYPE_SI intSI_type_node
 
 /* RISCV_FTYPE_ATYPESN takes N RISCV_FTYPES-like type codes and lists
    their associated RISCV_ATYPEs.  */
@@ -125,6 +127,7 @@ AVAIL (hard_float, TARGET_HARD_FLOAT)
   RISCV_ATYPE_##A, RISCV_ATYPE_##B
 
 static const struct riscv_builtin_description riscv_builtins[] = {
+  DIRECT_BUILTIN (pcntw, RISCV_SI_FTYPE_SI, bitmanip64),
   DIRECT_BUILTIN (frflags, RISCV_USI_FTYPE_VOID, hard_float),
   DIRECT_NO_TARGET_BUILTIN (fsflags, RISCV_VOID_FTYPE_USI, hard_float)
 };
diff --git a/gcc/config/riscv/riscv-ftypes.def b/gcc/config/riscv/riscv-ftypes.def
index eefe3033e..f91dac7d2 100644
--- a/gcc/config/riscv/riscv-ftypes.def
+++ b/gcc/config/riscv/riscv-ftypes.def
@@ -28,3 +28,4 @@ along with GCC; see the file COPYING3.  If not see
 
 DEF_RISCV_FTYPE (1, (USI, VOID))
 DEF_RISCV_FTYPE (1, (VOID, USI))
+DEF_RISCV_FTYPE (1, (SI, SI))
diff --git a/gcc/config/riscv/riscv.c b/gcc/config/riscv/riscv.c
index e7440f390..89fc181a1 100644
--- a/gcc/config/riscv/riscv.c
+++ b/gcc/config/riscv/riscv.c
@@ -374,6 +374,27 @@ riscv_build_integer_1 (struct riscv_integer_op codes[RISCV_MAX_INTEGER_OPS],
       return 1;
     }
 
+  /* ??? Maybe there are also other bitmanip instructions useful for loading
+     constants?  */
+  if (TARGET_64BIT && TARGET_BITMANIP)
+    {
+      if (ZERO_EXTENDED_SMALL_OPERAND (value))
+	{
+	  /* Simply ADDIWU.  */
+	  codes[0].code = UNKNOWN;
+	  codes[0].value = value;
+	  return 1;
+	}
+      else if (SINGLE_BIT_MASK_OPERAND (value))
+	{
+	  /* Simply SBSET.  */
+	  codes[0].code = UNKNOWN;
+	  codes[0].value = value;
+	  return 1;
+	}
+      /* ??? Can use slo/sro to load constants.  */
+    }
+
   /* End with ADDI.  When constructing HImode constants, do not generate any
      intermediate value that is not itself a valid HImode constant.  The
      XORI case below will handle those remaining HImode constants.  */
@@ -1601,12 +1622,21 @@ riscv_rtx_costs (rtx x, machine_mode mode, int outer_code, int opno ATTRIBUTE_UN
 
     case ZERO_EXTRACT:
       /* This is an SImode shift.  */
-      if (outer_code == SET && (INTVAL (XEXP (x, 2)) > 0)
+      if (outer_code == SET && GET_CODE (XEXP (x, 2)) == CONST_INT
+	  && (INTVAL (XEXP (x, 2)) > 0) && GET_CODE (XEXP (x, 1)) == CONST_INT
 	  && (INTVAL (XEXP (x, 1)) + INTVAL (XEXP (x, 2)) == 32))
 	{
 	  *total = COSTS_N_INSNS (SINGLE_SHIFT_COST);
 	  return true;
 	}
+      /* This is an sbext.  */
+      if (TARGET_BITMANIP && outer_code == SET
+	  && GET_CODE (XEXP (x, 1)) == CONST_INT
+	  && INTVAL (XEXP (x, 1)) == 1)
+	{
+	  *total = COSTS_N_INSNS (SINGLE_SHIFT_COST);
+	  return true;
+	}
       return false;
 
     case ASHIFT:
@@ -1885,7 +1915,21 @@ riscv_output_move (rtx dest, rtx src)
 	  }
 
       if (src_code == CONST_INT)
-	return "li\t%0,%1";
+	{
+	  if (SMALL_OPERAND (INTVAL (src)) || LUI_OPERAND (INTVAL (src)))
+	    return "li\t%0,%1";
+
+	  if (TARGET_BITMANIP && TARGET_64BIT)
+	    {
+	      if (ZERO_EXTENDED_SMALL_OPERAND (INTVAL (src)))
+		return "addiwu\t%0,zero,%s1";
+	      if (SINGLE_BIT_MASK_OPERAND (INTVAL (src)))
+		return "sbseti\t%0,zero,%S1";
+	    }
+
+	  /* Should never reach here.  */
+	  abort ();
+	}
 
       if (src_code == HIGH)
 	return "lui\t%0,%h1";
@@ -3147,7 +3191,9 @@ riscv_memmodel_needs_release_fence (enum memmodel model)
    'A'	Print the atomic operation suffix for memory model OP.
    'F'	Print a FENCE if the memory model requires a release.
    'z'	Print x0 if OP is zero, otherwise print OP normally.
-   'i'	Print i if the operand is not a register.  */
+   'i'	Print i if the operand is not a register.
+   's'  Sign-extend a 32-bit constant value to 64-bits then print.
+   'S'  Print shift-index of single-bit mask OP.  */
 
 static void
 riscv_print_operand (FILE *file, rtx op, int letter)
@@ -3187,6 +3233,27 @@ riscv_print_operand (FILE *file, rtx op, int letter)
         fputs ("i", file);
       break;
 
+    case 's':
+      {
+	rtx newop = GEN_INT (INTVAL (op) | 0xffffffffUL << 32);
+	output_addr_const (file, newop);
+	break;
+      }
+
+    case 'S':
+      {
+	rtx newop = GEN_INT (ctz_hwi (INTVAL (op)));
+	output_addr_const (file, newop);
+	break;
+      }
+
+    case 'T':
+      {
+	rtx newop = GEN_INT (ctz_hwi (~INTVAL (op)));
+	output_addr_const (file, newop);
+	break;
+      }
+	
     default:
       switch (code)
 	{
diff --git a/gcc/config/riscv/riscv.h b/gcc/config/riscv/riscv.h
index c93743f95..40da6530f 100644
--- a/gcc/config/riscv/riscv.h
+++ b/gcc/config/riscv/riscv.h
@@ -456,6 +456,18 @@ enum reg_class
   (((VALUE) | ((1UL<<31) - IMM_REACH)) == ((1UL<<31) - IMM_REACH)	\
    || ((VALUE) | ((1UL<<31) - IMM_REACH)) + IMM_REACH == 0)
 
+/* The following macros use B extension instructions to load constants.  */
+
+/* If this is a negative 32-bit value zero-extended to 64-bits, then we
+   can load it with addiwu if it is close enough to -1.  */
+#define ZERO_EXTENDED_SMALL_OPERAND(VALUE) \
+  (((VALUE & 0xffffffff) == VALUE) && (VALUE & 0x80000000)		\
+   && SMALL_OPERAND (VALUE | (0xffffffffUL << 32)))
+
+/* If this is a single bit mask, then we can load it with sbseti.  */
+#define SINGLE_BIT_MASK_OPERAND(VALUE) \
+  (pow2p_hwi (VALUE))
+
 /* Stack layout; function entry, exit and calling.  */
 
 #define STACK_GROWS_DOWNWARD 1
@@ -664,6 +676,13 @@ typedef struct {
 
 #define LOGICAL_OP_NON_SHORT_CIRCUIT 0
 
+/* Configure CLZ/CTZ behavior. */
+
+#define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) \
+  ((VALUE) = GET_MODE_UNIT_BITSIZE (MODE), 2)
+#define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) \
+  ((VALUE) = GET_MODE_UNIT_BITSIZE (MODE), 2)
+
 /* Control the assembler format that we output.  */
 
 /* Output to assembler file text saying following lines
diff --git a/gcc/config/riscv/riscv.md b/gcc/config/riscv/riscv.md
index e3799a5bd..33668a48e 100644
--- a/gcc/config/riscv/riscv.md
+++ b/gcc/config/riscv/riscv.md
@@ -43,6 +43,9 @@
   UNSPEC_LRINT
   UNSPEC_LROUND
 
+  ;; Bitmanip
+  UNSPEC_PCNTW
+
   ;; Stack tie
   UNSPEC_TIE
 ])
@@ -156,7 +159,7 @@
 (define_attr "type"
   "unknown,branch,jump,call,load,fpload,store,fpstore,
    mtc,mfc,const,arith,logical,shift,slt,imul,idiv,move,fmove,fadd,fmul,
-   fmadd,fdiv,fcmp,fcvt,fsqrt,multi,auipc,nop,ghost"
+   fmadd,fdiv,fcmp,fcvt,fsqrt,multi,auipc,nop,ghost,bitmanip"
   (cond [(eq_attr "got" "load") (const_string "load")
 
 	 ;; If a doubleword move uses these expensive instructions,
@@ -1043,11 +1046,16 @@
 
 ;; Extension insns.
 
-(define_insn_and_split "zero_extendsidi2"
+(define_expand "zero_extendsidi2"
+  [(set (match_operand:DI 0 "register_operand")
+	(zero_extend:DI (match_operand:SI 1 "nonimmediate_operand")))]
+  "TARGET_64BIT")
+
+(define_insn_and_split "*zero_extendsidi2_internal"
   [(set (match_operand:DI     0 "register_operand"     "=r,r")
 	(zero_extend:DI
 	    (match_operand:SI 1 "nonimmediate_operand" " r,m")))]
-  "TARGET_64BIT"
+  "TARGET_64BIT && !TARGET_BITMANIP"
   "@
    #
    lwu\t%0,%1"
@@ -1060,11 +1068,15 @@
   [(set_attr "move_type" "shift_shift,load")
    (set_attr "mode" "DI")])
 
-(define_insn_and_split "zero_extendhi<GPR:mode>2"
+(define_expand "zero_extendhi<GPR:mode>2"
+  [(set (match_operand:GPR 0 "register_operand")
+	(zero_extend:GPR (match_operand:HI 1 "nonimmediate_operand")))])
+
+(define_insn_and_split "*zero_extendhi<GPR:mode>2_internal"
   [(set (match_operand:GPR    0 "register_operand"     "=r,r")
 	(zero_extend:GPR
 	    (match_operand:HI 1 "nonimmediate_operand" " r,m")))]
-  ""
+  "!TARGET_BITMANIP"
   "@
    #
    lhu\t%0,%1"
@@ -2389,6 +2401,14 @@
   ""
   "")
 
+(define_insn "riscv_pcntw"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec
+	    [(match_operand:SI 1 "register_operand" "r")]
+	    UNSPEC_PCNTW))]
+  ""
+  "pcntw\t%0,%1")
+
 (define_insn "riscv_frflags"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(unspec_volatile [(const_int 0)] UNSPECV_FRFLAGS))]
@@ -2450,3 +2470,4 @@
 (include "pic.md")
 (include "generic.md")
 (include "sifive-7.md")
+(include "bitmanip.md")
diff --git a/gcc/config/riscv/riscv.opt b/gcc/config/riscv/riscv.opt
index 3b25f9a10..0a743afda 100644
--- a/gcc/config/riscv/riscv.opt
+++ b/gcc/config/riscv/riscv.opt
@@ -21,6 +21,9 @@
 HeaderInclude
 config/riscv/riscv-opts.h
 
+Variable
+HOST_WIDE_INT riscv_bitmanip_flags = 0
+
 mbranch-cost=
 Target RejectNegative Joined UInteger Var(riscv_branch_cost)
 -mbranch-cost=N	Set the cost of branches to roughly N instructions.
@@ -118,6 +121,8 @@ Mask(64BIT)
 
 Mask(MUL)
 
+Mask(BITMANIP)
+
 Mask(ATOMIC)
 
 Mask(HARD_FLOAT)
@@ -128,6 +133,42 @@ Mask(RVC)
 
 Mask(RVE)
 
+mbmi-zbb
+Target Mask(BITMANIP_ZBB) Var(riscv_bitmanip_flags)
+Support the base subset of the Bitmanip extension.
+
+mbmi-zbc
+Target Mask(BITMANIP_ZBC) Var(riscv_bitmanip_flags)
+Support the carry-less multiply subset of the Bitmanip extension.
+
+mbmi-zbe
+Target Mask(BITMANIP_ZBE) Var(riscv_bitmanip_flags)
+Support the bit extract/deposit subset of the Bitmanip extension.
+
+mbmi-zbf
+Target Mask(BITMANIP_ZBF) Var(riscv_bitmanip_flags)
+Support the extract-and-place subset of the Bitmanip extension.
+
+mbmi-zbm
+Target Mask(BITMANIP_ZBM) Var(riscv_bitmanip_flags)
+Support the bit matrix subset of the Bitmanip extension.
+
+mbmi-zbp
+Target Mask(BITMANIP_ZBP) Var(riscv_bitmanip_flags)
+Support the bit permutation subset of the Bitmanip extension.
+
+mbmi-zbr
+Target Mask(BITMANIP_ZBR) Var(riscv_bitmanip_flags)
+Support the CRC subset of the Bitmanip extension.
+
+mbmi-zbs
+Target Mask(BITMANIP_ZBS) Var(riscv_bitmanip_flags)
+Support the single bit subset of the Bitmanip extension.
+
+mbmi-zbt
+Target Mask(BITMANIP_ZBT) Var(riscv_bitmanip_flags)
+Support the ternary subset of the Bitmanip extension.
+
 mriscv-attribute
 Target Report Var(riscv_emit_attribute_p) Init(-1)
 Emit RISC-V ELF attribute.
