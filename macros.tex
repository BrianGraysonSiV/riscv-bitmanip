\chapter{Pseudo-Ops, Macros, Algorithms}

This chapter contains a collection of psudo-ops, macros, and algorithms using
the XBitmanip extension. For the sake of simplicity we assume RV32 for most
examples in this chapter.

Most assembler routines in this chapter are written as if they were ABI functions,
i.e. arguments are passed in a0, a1, \dots\ and results are returned in a0. Registers
t0, t1, \dots\ are used for spilling.

Some of the assembler routines below can not or should not overwrite their
first argument. In those cases the arguments are passed in a1, a2, \dots\ and
results are returned in a0.

\section{GREVI Pseudo-Ops}

Tables~\ref{pseudos-grevi32}~and~\ref{pseudos-grevi64} list assembler
pseudo-ops for commonly used {\tt grevi} commands.

\begin{table}[h]
\begin{small}
\begin{center}
\begin{tabular}{l l l}
Pseudoinstruction & Base Instruction(s) & Meaning \\ \hline

{\tt brev rd, rs} & {\tt grevi rd, rs, 31} & bitwise reverse \\
{\tt bswap rd, rs} & {\tt grevi rd, rs, 24} & reverse the byte order \\
{\tt bswap.h rd, rs} & {\tt grevi rd, rs, 8} & reverse the byte order in each half word \\
{\tt hswap rd, rs} & {\tt grevi rd, rs, 16} & reverse the order of half words \\

\hline

\end{tabular}
\end{center}
\end{small}
\caption{RV32 GREVI Pseudoinstructions.}
\label{pseudos-grevi32}
\end{table}

\begin{table}[h]
\begin{small}
\begin{center}
\begin{tabular}{l l l}
Pseudoinstruction & Base Instruction(s) & Meaning \\ \hline

{\tt brev rd, rs} & {\tt grevi rd, rs, 63} & bitwise reverse \\
{\tt bswap rd, rs} & {\tt grevi rd, rs, 56} & reverse the byte order \\
{\tt bswap.h rd, rs} & {\tt grevi rd, rs, 8} & reverse the byte order in each half word \\
{\tt bswap.w rd, rs} & {\tt grevi rd, rs, 24} & reverse the byte order in each word \\
{\tt hswap rd, rs} & {\tt grevi rd, rs, 48} & reverse the order of half words \\
{\tt hswap.w rd, rs} & {\tt grevi rd, rs, 16} & reverse the order of half words in each word \\
{\tt wswap rd, rs} & {\tt grevi rd, rs, 32} & reverse the order of words \\
\hline

\end{tabular}
\end{center}
\end{small}
\caption{RV64 GREVI Pseudoinstructions.}
\label{pseudos-grevi64}
\end{table}

\section{Bit Scanning Operations}

\subsubsection{Count Leading Zeros}

This is trivially just the \texttt{clz} instruction:

\begin{verbatim}
  clz a0, a0
\end{verbatim}

\subsubsection{Count Leading Ones}

Simply invert before executing the \texttt{clz} instruction:

\begin{verbatim}
  not a0, a0
  clz a0, a0
\end{verbatim}

\subsubsection{Find index of highest bit set (aka \texttt{ilog2})}

\begin{verbatim}
  clz a0, a0
  neg a0, a0
  addi a0, a0, 32
\end{verbatim}

\subsubsection{Find index of lowest bit set}

\begin{verbatim}
  brev a0, a0
  clz a0, a0
\end{verbatim}

\section{MIX/MUX Operations}

\subsubsection{MIX Operation}

A MIX operation selects bits from arguments a1 and a2 based on the bits in
the control word a0.

\begin{verbatim}
  and t0, a1, a0
  andc a0, a2, a0
  or a0, a0, t0
\end{verbatim}

\subsubsection{MUX Operation}

A MUX operation selects word a1 or a2 based on if the control word a0 is
zero or nonzero, without branching. (The {\tt snez} instruction is optional
if a0 is already either 0 or 1.)

\begin{verbatim}
  snez a0, a0
  neg a0, a0
  and t0, a1, a0
  andc a0, a2, a0
  or a0, a0, t0
\end{verbatim}

\section{Emulating other Bit Manipulation ISAs using macro-op fusion}

The following code snippets implement all instructions from the x86 bit manipulation
ISA extensions ABM, BMI1, BMI2, and TBM using RISC-V code that does not spill any
registers and thus could easily be implemented in a single instruction using macro-op
fusion. (Some of them simply map directly to instructions in this spec and so no
macro-op fusion is needed.) Note that shorter RISC-V code sequences are possible if
we allow spilling to temporary registers.

\begin{longtable}[c]{@{}llrrl@{}}
\caption{Emulating other Bit Manipulation ISAs using macro-op fusion}\tabularnewline
\toprule
x86 Ext & x86 Instruction & \multicolumn{2}{c}{Bytes} & RISC-V Code\tabularnewline
        &                 & x86 & RV            &\tabularnewline
\midrule
\endfirsthead
\toprule
x86 Ext & x86 Instruction & \multicolumn{2}{c}{Bytes} & RISC-V Code\tabularnewline
        &                 & x86 & RV            &\tabularnewline
\midrule
\endhead
ABM  & {\tt popcnt}           & 5 &  2 & {\tt c.pcnt a0, a0}\tabularnewline
\cline{2-5}
     & {\tt lzcnt}            & 5 &  2 & {\tt c.clz a0, a0}\tabularnewline
\midrule
BMI1 & {\tt andn}             & 5 &  4 & {\tt andc a0, a2, a1}\tabularnewline
\cline{2-5}
     & {\tt bextr} (regs)\footnote{
         The BMI1 {\tt bextr} instruction expects the length and start position packed in one
	 register operand. Our version expects the length in a0, start position in a1, and source
	 value in a2.
                             }& 5 & 12 & {\tt c.add a0, a0, a1}\tabularnewline
     &                        &   &    & {\tt slo a0, zero, a0}\tabularnewline
     &                        &   &    & {\tt c.and a0, a0, a2}\tabularnewline
     &                        &   &    & {\tt srl a0, a0, a1}\tabularnewline
\cline{2-5}
     & {\tt blsi}             & 5 &  6 & {\tt neg a0, a1}\tabularnewline
     &                        &   &    & {\tt c.and a0, a0, a1}\tabularnewline
\cline{2-5}
     & {\tt blsmsk}           & 5 &  6 & {\tt addi a0, a1, -1}\tabularnewline
     &                        &   &    & {\tt c.xor a0, a0, a1}\tabularnewline
\cline{2-5}
     & {\tt blsr}             & 5 &  6 & {\tt addi a0, a1, -1}\tabularnewline
     &                        &   &    & {\tt c.and a0, a0, a1}\tabularnewline
\midrule
BMI1 & {\tt bzhi}             & 5 &  6 & {\tt slo a0, zero, a2}\tabularnewline
     &                        &   &    & {\tt c.and a0, a0, a1}\tabularnewline
\cline{2-5}
     & {\tt mulx}             & 5 &  4 & {\tt mul}\tabularnewline
\cline{2-5}
     & {\tt pdep}             & 5 &  4 & {\tt bdep}\tabularnewline
\cline{2-5}
     & {\tt pext}             & 5 &  4 & {\tt bext}\tabularnewline
\cline{2-5}
     & {\tt rorx}             & 6 &  4 & {\tt rori}\tabularnewline
\cline{2-5}
     & {\tt sarx}             & 5 &  4 & {\tt sra}\tabularnewline
\cline{2-5}
     & {\tt shrx}             & 5 &  4 & {\tt srl}\tabularnewline
\cline{2-5}
     & {\tt shlx}             & 5 &  4 & {\tt sll}\tabularnewline
\midrule
TBM  & {\tt bextr} (imm)      & 7 &  4 & {\tt c.slli a0, a0, (32-START-LEN)}\tabularnewline
     &                        &   &    & {\tt c.srli a0, a0, (32-LEN)}\tabularnewline
\cline{2-5}
     & {\tt blcfill}          & 5 &  6 & {\tt addi a0, a1, 1}\tabularnewline
     &                        &   &    & {\tt c.and a0, a0, a1}\tabularnewline
\cline{2-5}
     & {\tt blci}             & 5 &  8 & {\tt addi a0, a1, 1}\tabularnewline
     &                        &   &    & {\tt c.not a0, a0}\tabularnewline
     &                        &   &    & {\tt c.or a0, a0, a1}\tabularnewline
\cline{2-5}
     & {\tt blcic}            & 5 & 10 & {\tt addi a0, a1, 1}\tabularnewline
     &                        &   &    & {\tt andc a0, a1, a0}\tabularnewline
     &                        &   &    & {\tt c.not a0, a0}\tabularnewline
\cline{2-5}
     & {\tt blcmsk}           & 5 &  6 & {\tt addi a0, a1, 1}\tabularnewline
     &                        &   &    & {\tt c.xor a0, a0, a1}\tabularnewline
\cline{2-5}
     & {\tt blcs}             & 5 &  6 & {\tt addi a0, a1, 1}\tabularnewline
     &                        &   &    & {\tt c.or a0, a0, a1}\tabularnewline
\cline{2-5}
     & {\tt blsfill}          & 5 &  6 & {\tt addi a0, a1, -1}\tabularnewline
     &                        &   &    & {\tt c.or a0, a0, a1}\tabularnewline
\cline{2-5}
     & {\tt blsic}            & 5 & 10 & {\tt addi a0, a1, -1}\tabularnewline
     &                        &   &    & {\tt andc a0, a1, a0}\tabularnewline
     &                        &   &    & {\tt c.not a0, a0}\tabularnewline
\cline{2-5}
     & {\tt t1mskc}           & 5 & 10 & {\tt addi a0, a1, +1}\tabularnewline
     &                        &   &    & {\tt andc a0, a1, a0}\tabularnewline
     &                        &   &    & {\tt c.not a0, a0}\tabularnewline
\cline{2-5}
     & {\tt t1msk}            & 5 &  8 & {\tt addi a0, a1, -1}\tabularnewline
     &                        &   &    & {\tt andc a0, a0, a1}\tabularnewline
\bottomrule
\end{longtable}

\section{Butterfly Operations}

The \texttt{grev}, \texttt{bext}, and \texttt{bdep} instructions are commonly
implemented using butterfly circuits\footnote{http://programming.sirrida.de/bit\_perm.html\#butterfly}.
(Butterfly circuits are a powerful tool for implementing bit permutations.)
However, sometimes one wants to use butterfly operations directly in a program
and it is not immediately obvious how to use GREVI and BDEP to perform
butterfly operations.

One can easily implement a single butterfly stage using GREVI in just four
instructions:

\begin{verbatim}
  grevi t0, a0, N
  and t0, t0, a1
  andc a0, a0, a1
  or a0, a0, t0
\end{verbatim}

With {\tt a0} containing the data input on entry and the result on exit. {\tt N} is a
power of two indicating which butterfly stage to implement, and {\tt a1} contains
an XLEN bitmask derived from the XLEN/2 butterfly control word.

This bitmask can either be pre-computed or, if it needs to be generated
on-the-fly, it can easily be calculated with the help of BDEP. For example
for the first butterfly stage (using a0 as input and output):

\begin{verbatim}
  li t0, 0x55555555
  bdep t0, a0, t0
  slli a0, t0, 1
  or a0, a0, t0
\end{verbatim}

Likewise for the second butterfly stage:

\begin{verbatim}
  li t0, 0x33333333
  bdep t0, a0, t0
  slli a0, t0, 2
  or a0, a0, t0
\end{verbatim}

For the third stage:

\begin{verbatim}
  li t0, 0x0f0f0f0f
  bdep t0, a0, t0
  slli a0, t0, 4
  or a0, a0, t0
\end{verbatim}

For the fourth stage:

\begin{verbatim}
  li t0, 0x00ff00ff
  bdep t0, a0, t0
  slli a0, t0, 8
  or a0, a0, t0
\end{verbatim}

And for the fifth stage:

\begin{verbatim}
  li t0, 0x0000ffff
  and t0, a0, t0
  slli a0, t0, 16
  or a0, a0, t0
\end{verbatim}
